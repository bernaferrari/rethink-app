<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexCondition:BraveAutoStartReceiver.kt$BraveAutoStartReceiver$!persistentState.prefAutoStartBootUp &amp;&amp; (intent.action == Intent.ACTION_BOOT_COMPLETED || intent.action == Intent.ACTION_REBOOT || intent.action == Intent.ACTION_LOCKED_BOOT_COMPLETED)</ID>
    <ID>ComplexCondition:BraveAutoStartReceiver.kt$BraveAutoStartReceiver$Intent.ACTION_REBOOT != intent.action &amp;&amp; Intent.ACTION_BOOT_COMPLETED != intent.action &amp;&amp; Intent.ACTION_LOCKED_BOOT_COMPLETED != intent.action &amp;&amp; Intent.ACTION_USER_UNLOCKED != intent.action &amp;&amp; Intent.ACTION_MY_PACKAGE_REPLACED != intent.action</ID>
    <ID>ComplexCondition:BraveVPNService.kt$BraveVPNService$!appConfig.isCustomSocks5Enabled() &amp;&amp; !appConfig.isCustomHttpProxyEnabled() &amp;&amp; !appConfig.isDnsProxyActive() &amp;&amp; !appConfig.isOrbotProxyEnabled()</ID>
    <ID>ComplexCondition:BraveVPNService.kt$BraveVPNService$(destIp.isZero &amp;&amp; who.startsWith(ID_WG_BASE)) || destIp.isZero || destIp.isLoopback</ID>
    <ID>ComplexCondition:BraveVPNService.kt$BraveVPNService$ROUTE4IN6 &amp;&amp; isAuto &amp;&amp; (has6 &amp;&amp; !has4)</ID>
    <ID>ComplexCondition:ConnTrackerDialog.kt$info.message.isEmpty() &amp;&amp; info.duration == 0 &amp;&amp; info.downloadBytes == 0L &amp;&amp; info.uploadBytes == 0L</ID>
    <ID>ComplexCondition:ConnectionTrackerAdapter.kt$ct.duration == 0 &amp;&amp; ct.downloadBytes == 0L &amp;&amp; ct.uploadBytes == 0L &amp;&amp; ct.message.isEmpty()</ID>
    <ID>ComplexCondition:CustomLanIpDialog.kt$!validateIpv4WithPrefix(gatewayV4, gatewayV4Prefix) || !validateIpv6WithPrefix(gatewayV6, gatewayV6Prefix) || !validateIpv4WithPrefix(routerV4, routerV4Prefix) || !validateIpv6WithPrefix(routerV6, routerV6Prefix) || !validateIpv4WithPrefix(dnsV4, dnsV4Prefix) || !validateIpv6WithPrefix(dnsV6, dnsV6Prefix)</ID>
    <ID>ComplexCondition:DnsLogTracker.kt$DnsLogTracker$transaction.response.isNotEmpty() &amp;&amp; transaction.response != UNSPECIFIED_IP_IPV4 &amp;&amp; transaction.response != UNSPECIFIED_IP_IPV6 &amp;&amp; transaction.response != EMPTY_RESPONSE</ID>
    <ID>ComplexCondition:NetworkReachabilityDialog.kt$!valid41 || !valid42 || !validUrl41 || !validUrl42 || !valid61 || !valid62 || !validUrl61 || !validUrl62</ID>
    <ID>ComplexCondition:RefreshDatabase.kt$RefreshDatabase$latestRefreshTime &gt; 0 &amp;&amp; current - latestRefreshTime &lt; FULL_REFRESH_INTERVAL &amp;&amp; (action == ACTION_REFRESH_AUTO || action == ACTION_REFRESH_INTERACTIVE)</ID>
    <ID>ComplexCondition:RethinkLogAdapter.kt$log.duration == 0 &amp;&amp; log.downloadBytes == 0L &amp;&amp; log.uploadBytes == 0L &amp;&amp; log.message.isEmpty()</ID>
    <ID>ComplexCondition:UIUtils.kt$UIUtils$seconds &gt; 0 || (days == 0 &amp;&amp; hours == 0 &amp;&amp; minutes == 0)</ID>
    <ID>ComplexCondition:WireguardManager.kt$WireguardManager$(it.id == WARP_ID &amp;&amp; it.name == WARP_NAME) || (it.id == SEC_WARP_ID &amp;&amp; it.name == SEC_WARP_NAME)</ID>
    <ID>CyclomaticComplexMethod:AntiCensorshipScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AntiCensorshipScreen( persistentState: PersistentState, eventLogger: EventLogger, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>CyclomaticComplexMethod:AppConfig.kt$AppConfig$private suspend fun onDnsChange(dt: DnsType)</ID>
    <ID>CyclomaticComplexMethod:AppDomainRulesDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AppDomainRulesSheet( uid: Int, domain: String, eventLogger: EventLogger, onDismiss: () -&gt; Unit, onUpdated: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:AppInfoScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AppInfoScreen( uid: Int, eventLogger: EventLogger, ipRulesViewModel: CustomIpViewModel, domainRulesViewModel: CustomDomainViewModel, networkLogsViewModel: AppConnectionsViewModel, onBackClick: () -&gt; Unit, onAppWiseIpLogsClick: (Int, Boolean) -&gt; Unit, onCustomRulesClick: (Int) -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:AppListScreen.kt$@OptIn(FlowPreview::class) @Composable fun AppListScreen( viewModel: AppInfoViewModel, eventLogger: EventLogger, refreshDatabase: RefreshDatabase, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>CyclomaticComplexMethod:BraveAutoStartReceiver.kt$BraveAutoStartReceiver$override fun onReceive(context: Context, intent: Intent)</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$fun parseIpAndPort(endpoint: String?): Pair&lt;String, Int&gt;</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$override fun flow( protocol: Int, _uid: Int, src: Gostr?, dst: Gostr?, realIps: Gostr?, d: Gostr?, possibleDomains: Gostr?, blocklists: Gostr? ): Mark</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$override fun onSharedPreferenceChanged(preferences: SharedPreferences?, key: String?)</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private fun builderStats(): String</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private fun interestingNetworkChanges( old: ConnectionMonitor.UnderlyingNetworks? = underlyingNetworks, _new: ConnectionMonitor.UnderlyingNetworks? = null, aux: OverlayNetworks = overlayNetworks ): NetworkChanges</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private fun isVpnDns(ip: String): Boolean</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private suspend fun bindAny( who: String, addrPort: String, fid: Long, nws: List&lt;ConnectionMonitor.NetworkProperties&gt; )</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private suspend fun determineDnsTransportIdForDFMode(uid: Int, domain: String, splitDns: Boolean, rinr: Boolean): Pair&lt;String, String&gt;</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private suspend fun determineProxyDetails( connTracker: ConnTrackerMetaData, doubleLoopback: Boolean, rinr: Boolean ): Mark</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private suspend fun establishVpn(networks: Networks, mtu: Int): ParcelFileDescriptor?</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private suspend fun firewall( connInfo: ConnTrackerMetaData, domains: String?, anyRealIpBlocked: Boolean = false, isSplApp: Boolean, rinr: Boolean ): FirewallRuleset</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private suspend fun getTransportIdForDnsFirewallMode(uid: Int, fqdn: String, rinr: Boolean): DNSOpts</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private suspend fun isSpecialApp(uid: Int): Boolean</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$private suspend fun newBuilder(): Builder</ID>
    <ID>CyclomaticComplexMethod:BraveVPNService.kt$BraveVPNService$suspend fun onNetworkConnected(networks: ConnectionMonitor.UnderlyingNetworks, forceRestart: Boolean = false)</ID>
    <ID>CyclomaticComplexMethod:BugReportZipper.kt$BugReportZipper$@RequiresApi(Build.VERSION_CODES.O) fun rezipAll(dir: File, file: File)</ID>
    <ID>CyclomaticComplexMethod:ConfigureOtherDnsScreen.kt$@Composable private fun DnsProxyDialogContent( appNames: List&lt;String&gt;, nextIndex: Int, appConfig: AppConfig, persistentState: PersistentState, scope: CoroutineScope, onDismiss: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:ConfigureRethinkBasicScreen.kt$@Composable private fun RethinkBlocklistContent( modifier: Modifier = Modifier, context: Context, blocklistType: RethinkBlocklistManager.RethinkBlocklistType, filters: MutableLiveData&lt;RethinkBlocklistState.Filters&gt;, remoteFileTagViewModel: RethinkRemoteFileTagViewModel, localFileTagViewModel: RethinkLocalFileTagViewModel, remoteBlocklistPacksMapViewModel: RemoteBlocklistPacksMapViewModel, localBlocklistPacksMapViewModel: LocalBlocklistPacksMapViewModel, showDownload: Boolean, showConfigure: Boolean, isDownloading: Boolean, showRemoteProgress: Boolean, activeView: RethinkBlocklistState.BlocklistView, filterLabelText: String, showPlusFilterSheet: Boolean, plusFilterTags: List&lt;FileTag&gt;, onActiveViewChanged: (RethinkBlocklistState.BlocklistView) -&gt; Unit, onFilterLabelTextChanged: (String) -&gt; Unit, onShowPlusFilterSheetChanged: (Boolean) -&gt; Unit, onPlusFilterTagsChanged: (List&lt;FileTag&gt;) -&gt; Unit, onDownloadBlocklist: () -&gt; Unit, onCancelDownload: () -&gt; Unit, onApplyChanges: () -&gt; Unit, onRevertChanges: () -&gt; Unit, onRefreshBlocklistAvailability: () -&gt; Unit, onProcessSelectedFileTags: (String) -&gt; Unit, onModifiedStampChanged: (String) -&gt; Unit, getStampValue: () -&gt; String, onDownloadStart: () -&gt; Unit, onDownloadFail: () -&gt; Unit, onDownloadSuccess: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:ConfigureRethinkBasicScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun ConfigureRethinkBasicScreen( screenType: ConfigureRethinkScreenType, remoteName: String = "", remoteUrl: String = "", uid: Int = Constants.MISSING_UID, persistentState: PersistentState, appConfig: AppConfig, appDownloadManager: AppDownloadManager, rethinkEndpointViewModel: RethinkEndpointViewModel, remoteFileTagViewModel: RethinkRemoteFileTagViewModel, localFileTagViewModel: RethinkLocalFileTagViewModel, remoteBlocklistPacksMapViewModel: RemoteBlocklistPacksMapViewModel, localBlocklistPacksMapViewModel: LocalBlocklistPacksMapViewModel, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>CyclomaticComplexMethod:ConnTrackerDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun ConnTrackerSheet( activity: FragmentActivity, info: ConnectionTracker, persistentState: PersistentState, eventLogger: EventLogger, onDismiss: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:ConnTrackerDialog.kt$private fun showFirewallRulesDialog( activity: FragmentActivity, info: ConnectionTracker ): RulesDialogContent</ID>
    <ID>CyclomaticComplexMethod:ConnectionMonitor.kt$ConnectionMonitor.NetworkRequestHandler$private suspend fun repopulateTrackedNetworks( opPrefs: OpPrefs, nwProps: LinkedHashSet&lt;NetworkProperties&gt; )</ID>
    <ID>CyclomaticComplexMethod:ConnectionTracer.kt$ConnectionTracer$@RequiresApi(Build.VERSION_CODES.Q) suspend fun getUidQ( protocol: Int, srcIp: String, srcPort: Int, dstIp: String, dstPort: Int, retryCount: Int = 0 ): Int</ID>
    <ID>CyclomaticComplexMethod:ConnectionTrackerAdapter.kt$private fun summaryInfo(context: Context, ct: ConnectionTracker): Summary</ID>
    <ID>CyclomaticComplexMethod:CustomLanIpDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun CustomLanIpSheet( persistentState: PersistentState, onDismiss: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:DetailedStatisticsScreen.kt$@Composable fun DetailedStatisticsScreen( viewModel: DetailedStatisticsViewModel, type: SummaryStatisticsType, timeCategory: TimeCategory, onBackClick: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:DnsDetailScreen.kt$@Composable fun DnsDetailScreen( viewModel: DnsSettingsViewModel, persistentState: PersistentState, appDownloadManager: AppDownloadManager, onCustomDnsClick: () -&gt; Unit, onRethinkPlusDnsClick: () -&gt; Unit, onLocalBlocklistConfigureClick: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>CyclomaticComplexMethod:DnsLogTracker.kt$DnsLogTracker$suspend fun makeDnsLogObj(transaction: Transaction): DnsLog</ID>
    <ID>CyclomaticComplexMethod:FirewallManager.kt$FirewallManager$fun getLabelForStatus(firewallStatus: FirewallStatus, connectionStatus: ConnectionStatus, prevConnStatus: ConnectionStatus): Int</ID>
    <ID>CyclomaticComplexMethod:FirewallRuleEvaluator.kt$FirewallRuleEvaluator$private suspend fun evaluateRulesInOrder( connInfo: ConnTrackerMetaData, domains: String?, anyRealIpBlocked: Boolean, isSplApp: Boolean, rinr: Boolean, uid: Int, appStatus: FirewallManager.FirewallStatus, connectionStatus: FirewallManager.ConnectionStatus, isTempAllowed: Boolean ): FirewallRuleset</ID>
    <ID>CyclomaticComplexMethod:FirewallRuleset.kt$FirewallRuleset.Companion$fun getFirewallRule(ruleId: String): FirewallRuleset?</ID>
    <ID>CyclomaticComplexMethod:FirewallRuleset.kt$FirewallRuleset.Companion$fun getRulesIcon(ruleId: String?): Int</ID>
    <ID>CyclomaticComplexMethod:FirewallRuleset.kt$FirewallRuleset.Companion$fun shouldShowHint(rule: String?): Boolean</ID>
    <ID>CyclomaticComplexMethod:GoVpnAdapter.kt$GoVpnAdapter$suspend fun refreshOrPauseOrResumeOrReAddProxies(isMobileActive: Boolean, ssid: String)</ID>
    <ID>CyclomaticComplexMethod:HomeNavigation.kt$@Composable fun HomeScreenRoot( homeUiState: HomeScreenUiState, onHomeStartStopClick: () -&gt; Unit, onHomeDnsClick: () -&gt; Unit, onHomeFirewallClick: () -&gt; Unit, onHomeProxyClick: () -&gt; Unit, onHomeLogsClick: () -&gt; Unit, onHomeAppsClick: () -&gt; Unit, onHomeSponsorClick: () -&gt; Unit, summaryViewModel: SummaryStatisticsViewModel, onOpenDetailedStats: (SummaryStatisticsType) -&gt; Unit, startDestination: HomeRoute, isDebug: Boolean, onConfigureAppsClick: () -&gt; Unit, onConfigureDnsClick: () -&gt; Unit, onConfigureFirewallClick: () -&gt; Unit, onFirewallUniversalClick: () -&gt; Unit, onFirewallCustomIpClick: () -&gt; Unit, onFirewallAppWiseIpClick: () -&gt; Unit, onConfigureProxyClick: () -&gt; Unit, onConfigureNetworkClick: () -&gt; Unit, onConfigureOthersClick: () -&gt; Unit, onConfigureLogsClick: () -&gt; Unit, onConfigureAntiCensorshipClick: () -&gt; Unit, onConfigureAdvancedClick: () -&gt; Unit, aboutUiState: AboutUiState, onSponsorClick: () -&gt; Unit, onTelegramClick: () -&gt; Unit, onBugReportClick: () -&gt; Unit, onWhatsNewClick: () -&gt; Unit, onAppUpdateClick: () -&gt; Unit, onContributorsClick: () -&gt; Unit, onTranslateClick: () -&gt; Unit, onWebsiteClick: () -&gt; Unit, onGithubClick: () -&gt; Unit, onFaqClick: () -&gt; Unit, onDocsClick: () -&gt; Unit, onPrivacyPolicyClick: () -&gt; Unit, onTermsOfServiceClick: () -&gt; Unit, onLicenseClick: () -&gt; Unit, onTwitterClick: () -&gt; Unit, onEmailClick: () -&gt; Unit, onRedditClick: () -&gt; Unit, onElementClick: () -&gt; Unit, onMastodonClick: () -&gt; Unit, onAppInfoClick: () -&gt; Unit, onVpnProfileClick: () -&gt; Unit, onNotificationClick: () -&gt; Unit, onStatsClick: () -&gt; Unit, onDbStatsClick: () -&gt; Unit, onFlightRecordClick: () -&gt; Unit, onEventLogsClick: () -&gt; Unit, onTokenClick: () -&gt; Unit, onTokenDoubleTap: () -&gt; Unit, onFossClick: () -&gt; Unit, onFlossFundsClick: () -&gt; Unit, snackbarHostState: SnackbarHostState, detailedStatsViewModel: DetailedStatisticsViewModel, domainConnectionsViewModel: DomainConnectionsViewModel, eventsViewModel: EventsViewModel, eventDao: EventDao, appInfoEventLogger: EventLogger, appInfoIpRulesViewModel: CustomIpViewModel, appInfoDomainRulesViewModel: CustomDomainViewModel, appInfoNetworkLogsViewModel: AppConnectionsViewModel, persistentState: PersistentState, appConfig: AppConfig, onOpenVpnProfile: () -&gt; Unit, onRefreshDatabase: (() -&gt; Unit)? = null, consoleLogViewModel: ConsoleLogViewModel, consoleLogRepository: ConsoleLogRepository, onShareConsoleLogs: () -&gt; Unit, onConsoleLogsDeleteComplete: () -&gt; Unit, proxyAppsMappingViewModel: ProxyAppsMappingViewModel, dnsSettingsViewModel: DnsSettingsViewModel, appDownloadManager: AppDownloadManager, onDnsCustomDnsClick: () -&gt; Unit, onDnsRethinkPlusDnsClick: () -&gt; Unit, onDnsLocalBlocklistConfigureClick: () -&gt; Unit, homeNavRequest: HomeNavRequest?, onHomeNavConsumed: () -&gt; Unit, onAppLockResult: (AppLockResult) -&gt; Unit = {}, // ConfigureRethinkBasic dependencies rethinkEndpointViewModel: RethinkEndpointViewModel, remoteFileTagViewModel: RethinkRemoteFileTagViewModel, localFileTagViewModel: RethinkLocalFileTagViewModel, remoteBlocklistPacksMapViewModel: RemoteBlocklistPacksMapViewModel, localBlocklistPacksMapViewModel: LocalBlocklistPacksMapViewModel, appInfoViewModel: AppInfoViewModel, refreshDatabase: RefreshDatabase, connectionTrackerViewModel: ConnectionTrackerViewModel, dnsLogViewModel: DnsLogViewModel, rethinkLogViewModel: RethinkLogViewModel, connectionTrackerRepository: ConnectionTrackerRepository, dnsLogRepository: DnsLogRepository, rethinkLogRepository: RethinkLogRepository, onConfigureOtherDns: (Int) -&gt; Unit, // ConfigureOtherDns dependencies dohViewModel: DoHEndpointViewModel, dotViewModel: DoTEndpointViewModel, dnsProxyViewModel: DnsProxyEndpointViewModel, dnsCryptViewModel: DnsCryptEndpointViewModel, dnsCryptRelayViewModel: DnsCryptRelayEndpointViewModel, oDohViewModel: ODoHEndpointViewModel, // UniversalFirewallSettings callbacks onNavigateToLogs: (String) -&gt; Unit, onOpenAccessibilitySettings: () -&gt; Unit, // WireGuard dependencies wgConfigViewModel: WgConfigViewModel, // Checkout dependencies checkoutViewModel: CheckoutViewModel?, onNavigateToProxy: () -&gt; Unit, // WgMain callbacks onWgCreateClick: () -&gt; Unit, onWgImportClick: () -&gt; Unit, onWgQrScanClick: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:HomeScreenActivity.kt$HomeScreenActivity$@Composable private fun HomeDialogHost()</ID>
    <ID>CyclomaticComplexMethod:HomeScreenActivity.kt$HomeScreenActivity$private fun collectAllBugReportFiles(): List&lt;BugReportFile&gt;</ID>
    <ID>CyclomaticComplexMethod:HomeScreenViewModel.kt$HomeScreenViewModel$private suspend fun updateUiWithProxyStates()</ID>
    <ID>CyclomaticComplexMethod:Logger.kt$Logger$fun log(tag: String, msg: String, type: LoggerLevel, e: Exception? = null)</ID>
    <ID>CyclomaticComplexMethod:NetworkBindingService.kt$NetworkBindingService$private suspend fun bindAny( who: String, addrPort: String, fid: Long, networks: List&lt;NetworkProperties&gt; ): Boolean</ID>
    <ID>CyclomaticComplexMethod:NetworkReachabilityDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun NetworkReachabilitySheet( persistentState: PersistentState, onDismiss: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:OneWgConfigAdapter.kt$@Composable fun OneWgConfigRow( config: WgConfigFiles, eventLogger: EventLogger, onDnsStatusChanged: () -&gt; Unit, onConfigDetailClick: (Int, WgType) -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:PipKeyManager.kt$PipKeyManager$private suspend fun publicKeyUsable(context: Context, retryCount: Int = 0, shouldPersistResult: Boolean): Pair&lt;Boolean, String&gt;</ID>
    <ID>CyclomaticComplexMethod:ProxyStateManager.kt$ProxyStateManager$suspend fun updateProxyStatus()</ID>
    <ID>CyclomaticComplexMethod:RefreshDatabase.kt$RefreshDatabase$suspend fun process(a: Action)</ID>
    <ID>CyclomaticComplexMethod:RethinkLogAdapter.kt$private fun summaryInfo(context: Context, log: RethinkLog): LogSummary</ID>
    <ID>CyclomaticComplexMethod:TcpProxyMainScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun TcpProxyMainScreen( appConfig: AppConfig, mappingViewModel: ProxyAppsMappingViewModel, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>CyclomaticComplexMethod:TunnelImporter.kt$TunnelImporter$suspend fun importTunnel( contentResolver: ContentResolver, uri: Uri, messageCallback: (CharSequence) -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:TunnelSettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun TunnelSettingsScreen( persistentState: PersistentState, appConfig: AppConfig, eventLogger: EventLogger, onOpenVpnProfile: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>CyclomaticComplexMethod:UniversalFirewallSettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun UniversalFirewallSettingsScreen( persistentState: PersistentState, eventLogger: EventLogger, connTrackerRepository: ConnectionTrackerRepository, onNavigateToLogs: (String) -&gt; Unit, onOpenAccessibilitySettings: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>CyclomaticComplexMethod:WgConfigAdapter.kt$@Composable fun WgConfigRow( config: WgConfigFiles, eventLogger: EventLogger, onDnsStatusChanged: () -&gt; Unit, onConfigDetailClick: (Int, WgType) -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:WgConfigDetailScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun WgConfigDetailScreen( configId: Int, wgType: WgType, persistentState: PersistentState, eventLogger: EventLogger, mappingViewModel: ProxyAppsMappingViewModel, onEditConfig: (Int, WgType) -&gt; Unit, onBackClick: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:WgConfigEditorScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun WgConfigEditorScreen( configId: Int, wgType: WgType, persistentState: PersistentState, onBackClick: () -&gt; Unit, onSaveSuccess: () -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:WgHopAdapter.kt$@Composable fun HopRow( context: Context, srcId: Int, config: Config, isActive: Boolean, selectedId: Int, onSelectedIdChange: (Int) -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:WgHopAdapter.kt$private suspend fun handleHop( context: Context, srcId: Int, config: Config, isChecked: Boolean, isActive: Boolean, selectedId: Int, onSelectedIdChange: (Int) -&gt; Unit ): Pair&lt;Boolean, String&gt;</ID>
    <ID>CyclomaticComplexMethod:WgInterface.kt$WgInterface$@Suppress("PARAMETER_NAME_CHANGED_ON_OVERRIDE") override fun equals(obj: Any?): Boolean</ID>
    <ID>CyclomaticComplexMethod:WgInterface.kt$WgInterface.Companion$@Throws(BadConfigException::class) fun parse(lines: Iterable&lt;CharSequence?&gt;): WgInterface</ID>
    <ID>CyclomaticComplexMethod:WgMainScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun WgMainScreen( wgConfigViewModel: WgConfigViewModel, persistentState: PersistentState, appConfig: AppConfig, eventLogger: EventLogger, onBackClick: () -&gt; Unit, onCreateClick: () -&gt; Unit, onImportClick: () -&gt; Unit, onQrScanClick: () -&gt; Unit, onConfigDetailClick: (Int, WgType) -&gt; Unit )</ID>
    <ID>CyclomaticComplexMethod:WireguardManager.kt$WireguardManager$fun getAllPossibleConfigIdsForApp(uid: Int, ip: String, port: Int, domain: String, usesMobileNw: Boolean, ssid: String, default: String): List&lt;String&gt;</ID>
    <ID>EmptyFinallyBlock:EnhancedBugReport.kt$EnhancedBugReport${ }</ID>
    <ID>EmptySecondaryConstructor:BadConfigException.kt$BadConfigException${}</ID>
    <ID>EmptySecondaryConstructor:ParseException.kt$ParseException${}</ID>
    <ID>ExplicitItLambdaParameter:AppDownloadManager.kt$AppDownloadManager${ i, it -&gt; val fileName = it.filename // url: https://dl.rethinkdns.com/update/blocklists?tstamp=1696197375609&amp;vcode=33 Logger.d(LOG_TAG_DOWNLOAD, "v: ($timestamp), f: $fileName, u: $it.url") downloadIds[i] = enqueueDownload(it.url, fileName, timestamp.toString()) if (downloadIds[i] == INVALID_DOWNLOAD_ID) { return DownloadManagerStatus.FAILURE } }</ID>
    <ID>ExplicitItLambdaParameter:GoVpnAdapter.kt$GoVpnAdapter${ it -&gt; val id = ID_WG_BASE + it.getId() val files = WireguardManager.getConfigFilesById(it.getId()) // skip one-wg proxy, mobile-only doesn't apply val isWireGuardMobileOnly = files?.useOnlyOnMetered == true &amp;&amp; !files.oneWireGuard val canResumeMobileWg = isWireGuardMobileOnly &amp;&amp; isMobileActive val useOnlyOnSsid = files?.ssidEnabled == true &amp;&amp; !files.oneWireGuard val configuredSsids = files?.ssids ?: "" val ssidMatch = WireguardManager.matchesSsidList(configuredSsids, ssid) &amp;&amp; ssid.isNotEmpty() val canResumeSsidWg = useOnlyOnSsid &amp;&amp; ssidMatch val canResume = canResumeMobileWg || canResumeSsidWg Logger.d( LOG_TAG_VPN, "$TAG refresh proxy: $id, mobileOnly: $isWireGuardMobileOnly, " + "canResumeMobileWg: $canResumeMobileWg, canResumeSsidWg: $canResumeSsidWg, isMobileActive: $isMobileActive, " + "useOnlyOnSsid: $useOnlyOnSsid, ssidMatch: $ssidMatch, ssid: $ssid, canResume: $canResume, wg-ssids: $configuredSsids" ) val stats = getProxyStatusById(id).first if (stats == null || stats == Backend.TNT) { Logger.w(LOG_TAG_VPN, "$TAG proxy stats for $id is null or tnt, $stats, re-adding") // there are cases where the proxy needs to be re-added, so pingOrReAddProxy // case: some of the wg proxies are added to tunnel but erring out, so // re-adding those proxies seems working, work around for now // now re-add logic is handled in go-tun // (github.com/celzero/firestack/blob/61187f88c1/intra/ipn/wgproxy.go#L404) addWgProxy(id, true) } if (stats == Backend.TPU &amp;&amp; canResume) { // if the proxy is paused, then resume it // this is needed when the tunnel is reconnected and the proxies are paused // so resume them, also when there is switch in wg-config for useOnlyOnMetered // or ssid change for ssidEnabled wgs val res = getProxies()?.getProxy(id.togs())?.resume() logEvent( Severity.LOW, "wireguard proxy resumed", "Wireguard proxy with id $id resumed successfully" ) Logger.i(LOG_TAG_VPN, "$TAG resumed proxy: $id, res: $res") } else if (isWireGuardMobileOnly &amp;&amp; !isMobileActive &amp;&amp; !canResume) { // if the proxy is not paused, then pause it // this is needed when the network is on mobile data // and the wg-config is set to useOnlyOnMetered val res = getProxies()?.getProxy(id.togs())?.pause() logEvent( Severity.LOW, "wireguard proxy paused", "Wireguard proxy with id $id paused successfully" ) Logger.i(LOG_TAG_VPN, "$TAG paused proxy (mobile): $id, res: $res") } else if (useOnlyOnSsid &amp;&amp; !ssidMatch &amp;&amp; !canResume) { // when the ssidEnabled is set and the ssid does not match val res = getProxies()?.getProxy(id.togs())?.pause() logEvent( Severity.LOW, "wireguard proxy paused", "Wireguard proxy with id $id paused successfully" ) Logger.i(LOG_TAG_VPN, "$TAG paused proxy (ssid): $id, res: $res") } if (stats == Backend.TPU &amp;&amp; !isWireGuardMobileOnly &amp;&amp; !useOnlyOnSsid) { // if the proxy is paused, then resume it // this is needed when the tunnel is reconnected and the proxies are paused val res = getProxies()?.getProxy(id.togs())?.resume() logEvent( Severity.LOW, "wireguard proxy resumed", "Wireguard proxy with id $id resumed successfully" ) Logger.i(LOG_TAG_VPN, "$TAG resumed proxy (non-metered/ssid): $id, res: $res") } }</ID>
    <ID>ExplicitItLambdaParameter:RetrofitManager.kt$RetrofitManager.Companion${ it -&gt; try { when (it) { OkHttpDnsType.DEFAULT -&gt; { return DnsOverHttps.Builder() .client(bootstrapClient) .url("https://dns.quad9.net/dns-query".toHttpUrl()) .bootstrapDnsHosts( getByIp("9.9.9.9"), getByIp("149.112.112.112"), getByIp("2620:fe::9"), getByIp("2620:fe::fe") ) .includeIPv6(true) .build() } OkHttpDnsType.CLOUDFLARE -&gt; { return DnsOverHttps.Builder() .client(bootstrapClient) .url("https://cloudflare-dns.com/dns-query".toHttpUrl()) .bootstrapDnsHosts( getByIp("1.1.1.1"), getByIp("1.0.0.1"), getByIp("2606:4700:4700::1111"), getByIp("2606:4700:4700::1001") ) .includeIPv6(true) .build() } OkHttpDnsType.GOOGLE -&gt; { return DnsOverHttps.Builder() .client(bootstrapClient) .url("https://dns.google/dns-query".toHttpUrl()) .bootstrapDnsHosts( getByIp("8.8.8.8"), getByIp("8.8.4.4"), getByIp("2001:4860:4860:0:0:0:0:8888"), getByIp("2001:4860:4860:0:0:0:0:8844") ) .includeIPv6(true) .build() } OkHttpDnsType.SYSTEM_DNS -&gt; { return Dns.SYSTEM } OkHttpDnsType.FALLBACK_DNS -&gt; { // todo: return retrieved system dns return null } } } catch (e: Exception) { Logger.crash(Logger.LOG_TAG_DOWNLOAD, "err; custom dns: ${e.message}", e) } }</ID>
    <ID>ExplicitItLambdaParameter:SummaryStatisticsViewModel.kt$SummaryStatisticsViewModel${ it -&gt; val to = System.currentTimeMillis() - it Pager(PagingConfig(Constants.LIVEDATA_PAGE_SIZE)) { statsDao.getTopActiveConns(to) } .flow .cachedIn(viewModelScope) }</ID>
    <ID>ForbiddenComment:AppConfig.kt$AppConfig$// FIXME: tunnel does not support both http and socks5 at once.</ID>
    <ID>ForbiddenComment:AppConfig.kt$AppConfig.TunProxyMode$// TODO: untangle the mess of proxy modes and providers</ID>
    <ID>ForbiddenComment:AppWiseDomainLogsScreen.kt$// TODO: check if this should be dynamic</ID>
    <ID>ForbiddenComment:BackgroundAccessibilityService.kt$BackgroundAccessibilityService$// FIXME: Figure out a fool-proof way to determine is launcher visible</ID>
    <ID>ForbiddenComment:BackgroundAccessibilityService.kt$BackgroundAccessibilityService$// TODO: Handle widgets on the homescreen</ID>
    <ID>ForbiddenComment:BackupAgent.kt$BackupAgent$// TODO: check if the journal files are needed for restore</ID>
    <ID>ForbiddenComment:BraveTileService.kt$BraveTileService$// TODO: should we check for last unlock time here?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$/*private suspend fun checkForPlusSubscription() { // initiate the billing client if it is not already initialized if (!InAppBillingHandler.isBillingClientSetup()) { InAppBillingHandler.initiate(this.applicationContext) Logger.i(LOG_TAG_VPN, "checkForPlusSubscription: billing client initiated") } else { Logger.i(LOG_TAG_VPN, "checkForPlusSubscription: billing client already setup") } // start the subscription check only if the user has enabled the feature // and the subscription check is not already in progress // invoke the work manager to check the subscription status if (RpnProxyManager.isRpnEnabled()) { io("rethinkPlusSubs") { handleRpnProxies() Logger.i(LOG_TAG_VPN, "checkForPlusSubscription(rpn): start work manager") val workManager = WorkManager.getInstance(this) val workRequest = OneTimeWorkRequestBuilder&lt;SubscriptionCheckWorker&gt;().build() workManager.enqueueUniqueWork( SubscriptionCheckWorker.WORK_NAME, ExistingWorkPolicy.REPLACE, workRequest ) } // TOOD: write listener to check the subscription status, if worker fails // reset the last check time } else { Logger.i(LOG_TAG_VPN, "checkForPlusSubscription(rpn): feature disabled") } } private suspend fun handleRpnProxies() { if (RpnProxyManager.isRpnActive()) { if (vpnAdapter == null) { Logger.i(LOG_TAG_VPN, "handleRpnProxies(rpn): adapter null, no-op") return } // win proxy is handled separately handleWinProxy() // TODO: get the list of other countries other than default, add all of them // make sure it doesn't exceed the max number of allowed configs (5) // if the user has selected a country, then add that country to the list val countries = RpnProxyManager.getSelectedCCs() if (countries.isNotEmpty()) { Logger.i(LOG_TAG_VPN, "$TAG handleRpnProxies: selected countries(rpn): $countries") // TODO: add the selected countries to the tunnel, new API needed } vpnAdapter?.setRpnAutoMode() } else { // either in pause mode or plus disabled Logger.i(LOG_TAG_VPN, "$TAG handleRpnProxies: plus disabled(rpn)") vpnAdapter?.unregisterWin() } } private suspend fun handleWinProxy() { val win = true // see if win is already registered and last connected is less than 60 mins val isWinRegistered = vpnAdapter?.isWinRegistered() == true Logger.d(LOG_TAG_VPN, "$TAG handleRpnProxies: win(rpn) test: $win, registered? $isWinRegistered") if (win &amp;&amp; !isWinRegistered) { var existingBytes = RpnProxyManager.getWinExistingData() // fetch existing win state if (existingBytes == null) { Logger.i(LOG_TAG_PROXY, "$TAG handleRpnProxies: win(rpn) state is null, fetching entitlement") existingBytes = RpnProxyManager.getWinEntitlement() } if (existingBytes == null || existingBytes.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG handleRpnProxies: win(rpn) entitlement is null or empty, cannot register") return } val bytes = registerAndFetchWinIfNeeded(existingBytes) RpnProxyManager.updateWinConfigState(bytes) Logger.i(LOG_TAG_VPN, "$TAG handleRpnProxies: exit64(rpn), registered? ${bytes != null}") } else if (isWinRegistered) { val lastConnectedTs = vpnAdapter?.getWinLastConnectedTs() if (lastConnectedTs != null &amp;&amp; abs(elapsedRealtime() - lastConnectedTs) &lt; WIN_LAST_CONNECTED_THRESHOLD_MS) { Logger.i(LOG_TAG_VPN, "$TAG handleRpnProxies: win(rpn) already registered, no-op") } else { // update the proxy as last connected time is more than 60 mins try { Logger.i(LOG_TAG_VPN, "$TAG handleRpnProxies: win(rpn) registered, updating") val bytes = vpnAdapter?.updateWin() if (bytes != null &amp;&amp; bytes.isEmpty()) { Logger.w(LOG_TAG_VPN, "$TAG handleRpnProxies: win(rpn) no update needed") return } // if the bytes are null, then it means the win is either failer to update or // no update is needed val updated = RpnProxyManager.updateWinConfigState(bytes) if (!updated) { Logger.w(LOG_TAG_VPN, "$TAG handleRpnProxies: win(rpn) update failed, no-op") //lastSubscriptionCheckTime = 0 // reset the last subscription check time return } // re-register the win proxy vpnAdapter?.registerAndFetchWinIfNeeded(bytes) } catch (e: Exception) { Logger.e(LOG_TAG_VPN, "$TAG handleRpnProxies: win(rpn) update failed", e) // fixme: find a way to handle this case // this is a work around for the case where the win is registered // but the last connected time is not updated, so we reset the // last subscription check time to 0, so that the next time for any // network request, it will try to update the win //lastSubscriptionCheckTime = 0 } } } } private suspend fun setRpnAutoMode() { val res = vpnAdapter?.setRpnAutoMode() logd("set rpn mode to: ${rpnMode()}, set? $res") handleRpnProxies() }*/</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// FIXME: update just that dns proxy, not the entire tunnel</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: #294 - Figure out a way to show users that the device is offline instead of status as</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: apply firewall rules on all real ips</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: as of now, vpn lockdown mode is not handled, check if this is required</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: call go to clear the cache</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: can remove multiple startForegroundService calls if we decide to remove</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: check for all networks instead of just the first one</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: check if the transport id is set to default/Auto, then return empty string/base</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: convert the duration obj to long, this is work around</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: do we need to still exclude the routes in case of noRoutes?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: handle multiple domains, for now, use the first domain</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: if uid is received, then make sure Rethink uid always returns Default as transport</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: like Intra, call VpnController#stop instead? see</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: no need to call addTransport in case of relay changes, which we are doing now</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: remove volatile</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: send an alert/notification instead?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: should allowFamily be set?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: should handle the LanIp.GATEWAY, LanIp.ROUTER addresses as well</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: should this check be a combination of cellular &amp; metered?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: should we check for last unlock time here?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: should we check for lockdown mode and decide to restart? or just restart always?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// TODO: show alerts to user on such exceptions, in a separate ui?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService$// not needed as the refresh is done in go, TODO: remove below code later</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService.Companion$// TODO: increase it to 6 hours?</ID>
    <ID>ForbiddenComment:BraveVPNService.kt$BraveVPNService.Companion$// TODO: should be different for IPv4 and IPv6, but for now it is same</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor$// TODO: process after a delay to avoid processing multiple network changes in short bursts</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor$// TODO: use a custom Looper(HandlerThread) to avoid blocking the main thread</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor.Companion$// TODO: set it to true when the reachability checks are required to be done from</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor.NetworkRequestHandler$// TODO: add http url probes for ipv4 and ipv6</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor.NetworkRequestHandler$// TODO: case: CAPTIVE_PORTAL, should we not test reachability?</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor.NetworkRequestHandler$// TODO: consider checking for NET_CAPABILITY_NOT_SUSPENDED, NET_CAPABILITY_VALIDATED?</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor.NetworkRequestHandler$// TODO: handle transport types like bluetooth, ethernet which may not have</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor.NetworkRequestHandler$// TODO: revisit this logic, see if this also needs similar treatment as</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor.NetworkRequestHandler$// TODO: use currentNetworks instead of trackedIpv4Networks and trackedIpv6Networks</ID>
    <ID>ForbiddenComment:ConnectionMonitor.kt$ConnectionMonitor.ProbeResult$// TODO: send only the required capabilities to the handler instead of the whole</ID>
    <ID>ForbiddenComment:Constants.kt$Constants.Companion$// FIXME: Avoid usage of these parameters, map to POJO instead</ID>
    <ID>ForbiddenComment:Constants.kt$Constants.Companion$// TODO: have two different response versions for blocklist update and app update</ID>
    <ID>ForbiddenComment:DnsLogTracker.kt$DnsLogTracker$// TODO: rdata should be either empty / 0.0.0.0 / ::0 / -- for block all</ID>
    <ID>ForbiddenComment:FavIconDownloader.kt$FavIconDownloader$// FIXME: add metadata instead of boolean</ID>
    <ID>ForbiddenComment:FirewallManager.kt$FirewallManager$// TODO: Use the package-manager API instead</ID>
    <ID>ForbiddenComment:FirewallManager.kt$FirewallManager.GlobalVariable$// TODO: protect access to the foregroundUids (read/write)</ID>
    <ID>ForbiddenComment:FirewallRuleset.kt$FirewallRuleset$// TODO: Add label and description from strings.xml</ID>
    <ID>ForbiddenComment:FirewallRuleset.kt$FirewallRuleset.Companion$// TODO: Move ico to enum var like for label and desc</ID>
    <ID>ForbiddenComment:GoVpnAdapter.kt$GoVpnAdapter$// TODO: #321 As of now there is no block free transport for dns types other than Rethink.</ID>
    <ID>ForbiddenComment:GoVpnAdapter.kt$GoVpnAdapter$// TODO: ideally the values required for transport, alg and rdns should be set in the</ID>
    <ID>ForbiddenComment:GoVpnAdapter.kt$GoVpnAdapter$// TODO: notify the user that the default transport could not be set</ID>
    <ID>ForbiddenComment:GoVpnAdapter.kt$GoVpnAdapter$// TODO: should show notification if the transport is not added?</ID>
    <ID>ForbiddenComment:GoVpnAdapter.kt$GoVpnAdapter$// TODO: system dns may be non existent; see: AppConfig#updateSystemDnsServers</ID>
    <ID>ForbiddenComment:HomeNavigation.kt$// TODO: Fetch app name asynchronously</ID>
    <ID>ForbiddenComment:HomeNavigation.kt$// TODO: Load icon if needed</ID>
    <ID>ForbiddenComment:HomeScreenActivity.kt$HomeScreenActivity$// FIXME: remove this post v054</ID>
    <ID>ForbiddenComment:HomeScreenActivity.kt$HomeScreenActivity$// TODO: modify this to use the latest version code api</ID>
    <ID>ForbiddenComment:HomeScreenActivity.kt$HomeScreenActivity$// TODO: prompt dialog to user that Playservice is disabled, so switch to update</ID>
    <ID>ForbiddenComment:HomeScreenActivity.kt$HomeScreenActivity$// TODO: remove this post v054.</ID>
    <ID>ForbiddenComment:HomeScreenActivity.kt$HomeScreenActivity$// TODO: see if this can be replaced with a more robust solution</ID>
    <ID>ForbiddenComment:IpRulesManager.kt$IpRulesManager$// TODO: is this needed in database?</ID>
    <ID>ForbiddenComment:LocalBlocklistCoordinator.kt$LocalBlocklistCoordinator$// downloaded. TODO: Later add checksum matching as well</ID>
    <ID>ForbiddenComment:NetLogTracker.kt$NetLogTracker$// TODO: This method should be part of BraveVPNService</ID>
    <ID>ForbiddenComment:PaymentWorker.kt$PaymentWorker$// TODO: get refId from EncryptedFile</ID>
    <ID>ForbiddenComment:PersistentState.kt$PersistentState$// TODO: add routes as normal but do not send fd to netstack</ID>
    <ID>ForbiddenComment:PersistentState.kt$PersistentState$// biometric authentication TODO: remove this</ID>
    <ID>ForbiddenComment:PipKeyManager.kt$PipKeyManager$// TODO: should we get the response from the publicKeyUsable method instead of</ID>
    <ID>ForbiddenComment:ProxyManager.kt$ProxyManager.ProxyMode$// TODO: consider adding other proxy modes (e.g, Wireguard, Rethink, etc.)</ID>
    <ID>ForbiddenComment:RefreshDatabase.kt$RefreshDatabase$// TODO: implement upsert logic handling all the edge cases</ID>
    <ID>ForbiddenComment:RestoreAgent.kt$RestoreAgent$// TODO: revisit this after v055 release</ID>
    <ID>ForbiddenComment:RethinkBlocklistManager.kt$RethinkBlocklistManager$// TODO: merge both the remote and local json parsing into one</ID>
    <ID>ForbiddenComment:RethinkBlocklistManager.kt$RethinkBlocklistManager$// TODO: move this strings to strings.xml</ID>
    <ID>ForbiddenComment:RethinkDnsEndpointDao.kt$RethinkDnsEndpointDao$// TODO: remove this method post v054 versions</ID>
    <ID>ForbiddenComment:RpnProxyManager.kt$/* import Logger.LOG_TAG_PROXY import android.content.Context import com.celzero.bravedns.RethinkDnsApplication.Companion.DEBUG import com.celzero.bravedns.database.RpnProxy import com.celzero.bravedns.database.RpnProxyRepository import kotlin.collections.find import com.celzero.bravedns.database.SubscriptionStateHistoryDao import com.celzero.bravedns.database.SubscriptionStatus import com.celzero.bravedns.database.SubscriptionStatusRepository import com.celzero.bravedns.iab.InAppBillingHandler import com.celzero.bravedns.iab.PurchaseDetail import com.celzero.bravedns.scheduler.WorkScheduler import com.celzero.bravedns.service.DomainRulesManager import com.celzero.bravedns.service.EncryptedFileManager import com.celzero.bravedns.service.IpRulesManager import com.celzero.bravedns.service.PersistentState import com.celzero.bravedns.service.VpnController import com.celzero.bravedns.subscription.StateMachineStatistics import com.celzero.bravedns.subscription.SubscriptionStateMachineV2 import com.celzero.bravedns.util.Constants import com.celzero.bravedns.util.Constants.Companion.RPN_PROXY_FOLDER_NAME import com.celzero.bravedns.util.UIUtils import com.celzero.bravedns.util.Utilities import com.celzero.firestack.backend.Backend import com.celzero.firestack.backend.RpnServers import com.celzero.firestack.settings.Settings import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.SupervisorJob import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.launch import org.json.JSONObject import org.koin.core.component.KoinComponent import org.koin.core.component.inject import java.io.File import java.time.Instant import java.util.concurrent.CopyOnWriteArraySet object RpnProxyManager : KoinComponent { private val applicationContext: Context by inject() private const val TAG = "RpnMgr" private var preferredId = Backend.Auto private val db: RpnProxyRepository by inject() private val subsDb: SubscriptionStatusRepository by inject() private val subsHistoryDb: SubscriptionStateHistoryDao by inject() private val workScheduler by inject&lt;WorkScheduler&gt;() private val persistentState by inject&lt;PersistentState&gt;() private const val WIN_ID = 4 private const val WIN_NAME = "WIN" private const val WIN_ENTITLEMENT_FILE_NAME = "win_response.json" private const val WIN_STATE_FILE_NAME = "win_state.json" const val MAX_WIN_SERVERS = 5 private var winConfig: ByteArray? = null private var winServers: Set&lt;RpnWinServer&gt; = emptySet() private val rpnProxies = CopyOnWriteArraySet&lt;RpnProxy&gt;() private val selectedCountries = mutableSetOf&lt;String&gt;() private val subscriptionStateMachine: SubscriptionStateMachineV2 by inject() private val stateObserverJob = SupervisorJob() private val stateObserverScope = CoroutineScope(Dispatchers.IO + stateObserverJob) init { io { try { load() startStateObserver() Logger.i( LOG_TAG_PROXY, "$TAG; RpnProxyManager initialized with state machine integration" ) } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error during initialization: ${e.message}", e) // Continue without state machine if initialization fails } } } enum class RpnTunMode(val id: Int) { NONE(Settings.AutoModeLocal), ANTI_CENSORSHIP(Settings.AutoModeHybrid), HIDE_IP(Settings.AutoModeRemote); companion object { fun fromId(id: Int) = entries.first { it.id == id } fun getTunModeForAuto(): Int { return when (rpnMode()) { RpnMode.NONE -&gt; NONE.id RpnMode.ANTI_CENSORSHIP -&gt; ANTI_CENSORSHIP.id RpnMode.HIDE_IP -&gt; HIDE_IP.id } } } } enum class RpnMode(val id: Int) { NONE(0), ANTI_CENSORSHIP(1), HIDE_IP(2); companion object { fun fromId(id: Int) = RpnMode.entries.first { it.id == id } fun getPreferredId(id: Int): String { val mode = fromId(id) return when (mode) { NONE -&gt; "" ANTI_CENSORSHIP -&gt; getPreferredId() HIDE_IP -&gt; getPreferredId() } } } fun isAntiCensorship() = this == ANTI_CENSORSHIP fun isHideIp() = this == HIDE_IP fun isNone() = this == NONE } enum class RpnState(val id: Int) { DISABLED(0), PAUSED(1), // not used in the app, but kept for future use ENABLED(2); companion object { fun fromId(id: Int) = RpnState.entries.first { it.id == id } } fun isEnabled() = this == ENABLED fun isPaused() = this == PAUSED fun isInactive() = this == DISABLED } data class RpnWinServer(val names: String, val countryCode: String, val address: String, val isActive: Boolean) fun isRpnActive(): Boolean { val isEnabled = RpnState.fromId(persistentState.rpnState).isEnabled() val isActive = !rpnMode().isNone() return isEnabled &amp;&amp; isActive } fun isRpnEnabled() = RpnState.fromId(persistentState.rpnState).isEnabled() fun rpnMode() = RpnMode.fromId(persistentState.rpnMode) fun rpnState() = RpnState.fromId(persistentState.rpnState) fun setRpnMode(mode: RpnMode) { if (rpnMode() == mode) { Logger.i(LOG_TAG_PROXY, "$TAG; rpn mode already set to ${RpnMode.getPreferredId(mode.id)}, skipping") return } persistentState.rpnMode = mode.id Logger.i(LOG_TAG_PROXY, "$TAG; rpn mode set to $${RpnMode.getPreferredId(mode.id)}") } fun deactivateRpn(reason: String = "manual deactivation") { Logger.i(LOG_TAG_PROXY, "$TAG; deactivating RPN, reason: $reason, current state: ${rpnState().name}") if (persistentState.rpnState == RpnState.DISABLED.id) { Logger.i(LOG_TAG_PROXY, "$TAG; rpn already deactivated, skipping") return } // no need to check the state, as user can manually deactivate RPN persistentState.rpnState = RpnState.DISABLED.id } fun activateRpn(purchase: PurchaseDetail, newPayload: String? = null) { if (persistentState.rpnState == RpnState.ENABLED.id) { Logger.i(LOG_TAG_PROXY, "$TAG; rpn already activated, skipping") return } val currentState = subscriptionStateMachine.getCurrentState() // Check if current state allows RPN activation if (!subscriptionStateMachine.hasValidSubscription()) { Logger.w(LOG_TAG_PROXY, "$TAG; cannot activate RPN - no valid subscription, current state: ${currentState.name}") return } try { persistentState.rpnState = RpnState.ENABLED.id setRpnProductId(purchase.productId) persistentState.showConfettiOnRPlus = true io { val payload = if (newPayload != null &amp;&amp; newPayload.isNotEmpty()) { // If new payload is provided, use it to update the purchase payload Logger.i(LOG_TAG_PROXY, "$TAG; updating purchase payload with new data") newPayload } else { // Otherwise, use the existing payload from the purchase purchase.payload } storeWinEntitlement(payload) } Logger.i( LOG_TAG_PROXY, "$TAG; rpn activated, mode: ${rpnMode()}, product: ${purchase.productId}" ) } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error activating RPN: ${e.message}", e) // Rollback on error persistentState.rpnState = RpnState.DISABLED.id throw e } } fun getSessionTokenFromPayload(payload: String): String { // "developerPayload":"{\"ws\":{\"cid\":\"aa95f04efcb19a54c7605a02e5dd0b435906b993d12bec031a60f3f1272f4f0e\",\"sessiontoken\":\"22695:4:1752256088:524537c17ba103463ba1d330efaf05c146ba3404af:023f958b6c1949568f55078e3c58fe6885d3e57322\",\"expiry\":\"2025-08-11T00:00:00.000Z\",\"status\":\"valid\"}}" try { val json = JSONObject(payload) val ws = json.getJSONObject("ws") val sessionToken = ws.getString("sessiontoken") Logger.i(LOG_TAG_PROXY, "$TAG; session token parsed from payload? ${sessionToken.isNotEmpty()}") return sessionToken } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error parsing session token from payload: ${e.message}", e) } return "" } fun getExpiryFromPayload(payload: String): Long? { // "developerPayload":"{\"ws\":{\"cid\":\"aa95f04efcb19a54c7605a02e5dd0b435906b993d12bec031a60f3f1272f4f0e\",\"sessiontoken\":\"22695:4:1752256088:524537c17ba103463ba1d330efaf05c146ba3404af:023f958b6c1949568f55078e3c58fe6885d3e57322\",\"expiry\":\"2025-08-11T00:00:00.000Z\",\"status\":\"valid\"}}" try { val json = JSONObject(payload) val ws = json.getJSONObject("ws") val expiryStr = ws.getString("expiry") val timestamp: Long = Instant.parse(expiryStr).toEpochMilli() Logger.i(LOG_TAG_PROXY, "$TAG; expiry parsed from payload: $timestamp") return timestamp } catch (e: Exception) { Logger.w(LOG_TAG_PROXY, "$TAG; error parsing expiry from payload: ${e.message}") } return null } suspend fun storeWinEntitlement(payload: String) { // Store the win entitlement in a file and the path in serverResponsePath try { // "developerPayload":"{\"ws\":{\"cid\":\"aa95f04efcb19a54c7605a02e5dd0b435906b993d12bec031a60f3f1272f4f0e\",\"sessiontoken\":\"22695:4:1752256088:524537c17ba103463ba1d330efaf05c146ba3404af:023f958b6c1949568f55078e3c58fe6885d3e57322\",\"expiry\":\"2025-08-11T00:00:00.000Z\",\"status\":\"valid\"}}" val json = JSONObject(payload) val ws = json.getJSONObject("ws") val fileName = getJsonResponseFileName(WIN_ID) val file = File(applicationContext.getExternalFilesDir(RPN_PROXY_FOLDER_NAME), fileName) val res = EncryptedFileManager.write(applicationContext, ws.toString(), file) // update the winConfig with the file path winConfig = ws.toString().toByteArray() val winProxy = db.getProxyById(WIN_ID) val ll = if (winProxy != null) { winProxy.serverResPath = file.absolutePath db.update(winProxy) } else { // insert a new proxy entry if it doesn't exist val newWinProxy = RpnProxy( id = WIN_ID, name = WIN_NAME, configPath = "", serverResPath = file.absolutePath, isActive = true, isLockdown = false, createdTs = System.currentTimeMillis(), modifiedTs = System.currentTimeMillis(), misc = "", tunId = "", latency = 0, lastRefreshTime = System.currentTimeMillis() ) db.insert(newWinProxy).toInt() } if (ll &lt; 0) { Logger.w(LOG_TAG_PROXY, "$TAG; error updating win proxy in db, result: $ll") } else { Logger.i(LOG_TAG_PROXY, "$TAG; win proxy updated in db, result: $ll") } Logger.i(LOG_TAG_PROXY, "$TAG; win entitlement stored in file: $fileName, result: $res") } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error storing win configs: ${e.message}", e) } } fun changePreferredId(id: String) { if (id.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; err; preferred id is empty, resetting to default") preferredId = Backend.Auto return } preferredId = id Logger.i(LOG_TAG_PROXY, "$TAG; preferred id changed to $preferredId") } fun getPreferredId(): String { Logger.v(LOG_TAG_PROXY, "$TAG; getPreferredId: $preferredId") return preferredId } fun getRpnProductId(): String { return persistentState.rpnProductId } fun setRpnProductId(productId: String) { persistentState.rpnProductId = productId } enum class RpnType(val id: Int) { EXIT(0), WIN(1); companion object { fun fromId(id: Int) = entries.first { it.id == id } } } data class RpnProps(val id: String, val status: Long, val type: String, val kids: String, val addr: String, val created: Long, val expires: Long, val who: String, val locations: RpnServers) { override fun toString(): String { val cts = getTime(created) val ets = getTime(expires) val s = applicationContext.getString(UIUtils.getProxyStatusStringRes(status)) return "id = $id\nstatus = $s\ntype = $type\nkids = $kids\naddr = $addr\ncreated = $cts\nexpires = $ets\nwho = $who\nlocations = $locations" } } private fun getTime(time: Long): String { return Utilities.convertLongToTime(time, Constants.TIME_FORMAT_4) } suspend fun load(): Int { // need to read the filepath from database and load the file // there will be an entry in the database for each RPN proxy selectedCountries.clear() val rp = db.getAllProxies() Logger.i(LOG_TAG_PROXY, "$TAG; init load, db size: ${rp.size}") rpnProxies.addAll(rp) rp.forEach { try { val cfgFile = File(it.configPath) if (!cfgFile.exists() &amp;&amp; it.id != WIN_ID) { // win proxy is handled differently Logger.w(LOG_TAG_PROXY, "$TAG; load, file not found: ${it.configPath} for ${it.name}") return@forEach } when (it.id) { WIN_ID -&gt; { // read the win entitlement file val entitlementFile = File(it.serverResPath) val entitlement = EncryptedFileManager.readByteArray(applicationContext, entitlementFile) val state = EncryptedFileManager.readByteArray(applicationContext, cfgFile) if (state.isEmpty()) { Logger.d(LOG_TAG_PROXY, "$TAG; win state file is empty (path: ${cfgFile.absolutePath}, using entitlement") winConfig = entitlement } else { winConfig = state } Logger.i(LOG_TAG_PROXY, "$TAG; win config loaded, ${winConfig?.isNotEmpty()}") } } } catch (e: Exception) { Logger.w(LOG_TAG_PROXY, "$TAG; err loading rpn proxy: ${it.name}, ${e.message}") } } selectedCountries.addAll(DomainRulesManager.getAllUniqueCCs()) // add the domain rules cc selectedCountries.addAll(IpRulesManager.getAllUniqueCCs()) // add the ip rules cc Logger.d( LOG_TAG_PROXY, "$TAG; total selected countries: ${selectedCountries.size}, $selectedCountries" ) // subsDb.deleteAll() // subsHistoryDb.clearHistory() return rp.size } fun getProxy(type: RpnType): RpnProxy? { return when (type) { RpnType.WIN -&gt; { rpnProxies.find { it.name == WIN_NAME || it.name == WIN_NAME.lowercase() } } else -&gt; null } } // This function is called from RpnProxiesUpdateWorker suspend fun registerNewProxy(type: RpnType): Boolean { // in case of update failure, call register with null when (type) { RpnType.WIN -&gt; { // check if state is there if not, fetch the entitlement var bytes = getWinExistingData() // fetch existing win state if (bytes == null) { Logger.i(LOG_TAG_PROXY, "$TAG; win state is null, fetching entitlement") bytes = getWinEntitlement() } if (bytes == null || bytes.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; win entitlement is null or empty, cannot register") return false } val currBytes = VpnController.registerAndFetchWinConfig(bytes) ?: return false val ok = updateWinConfigState(currBytes) winServers = fetchAndConstructWinLocations() if (winServers.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; no win servers found, retry") io { retryLocationFetch() } } return ok } else -&gt; { Logger.e(LOG_TAG_PROXY, "$TAG; err; invalid type for register: $type") return false } } } suspend fun retryLocationFetch() { // keep retrying to fetch win properties for next 15 sec and see // if the locations are available for (i in 1..15) { Logger.i(LOG_TAG_PROXY, "$TAG; retrying to fetch win properties, attempt: $i") winServers = fetchAndConstructWinLocations() if (winServers.isNotEmpty()) { Logger.i(LOG_TAG_PROXY, "$TAG; win servers found after retry, attempt: $i, size: ${winServers.size}") break } Thread.sleep(1000L) // wait for 1 second before next retry } } suspend fun getWinServers(): List&lt;RpnWinServer&gt; { if (winServers.isNotEmpty()) { return winServers.toList() } Logger.w(LOG_TAG_PROXY, "$TAG; win servers are empty, fetching from tun") winServers = fetchAndConstructWinLocations() return winServers.toList() } suspend fun getWinEntitlement(): ByteArray? { if (winConfig == null || winConfig!!.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; win config is null or empty, returning empty byte array") // read from database if available val winProxy = db.getProxyById(WIN_ID) if (winProxy != null) { val file = File(winProxy.serverResPath) val bytes = EncryptedFileManager.readByteArray(applicationContext, file) if (bytes.isNotEmpty()) { Logger.i(LOG_TAG_PROXY, "$TAG; win proxy found in db, returning bytes") return bytes } else { Logger.w(LOG_TAG_PROXY, "$TAG; win proxy file is empty, returning null") return null } } else { Logger.w(LOG_TAG_PROXY, "$TAG; win proxy not found in db, returning null") return null } } else { Logger.i(LOG_TAG_PROXY, "$TAG; win config is not null, returning bytes") return winConfig } } suspend fun updateWinConfigState(byteArray: ByteArray?): Boolean { if (byteArray == null || byteArray.isEmpty()) { Logger.e(LOG_TAG_PROXY, "$TAG; err; byte array is null for win config") return false } try { val res = updateWinConfigToFileAndDb(byteArray) Logger.i(LOG_TAG_PROXY, "$TAG; win config saved? $res") if (res) { winConfig = byteArray Logger.i(LOG_TAG_PROXY, "$TAG; win config updated") } return res } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; err updating win config: ${e.message}", e) } return false } suspend fun getWinExistingData(): ByteArray? { return getExistingData(WIN_ID) } private suspend fun getExistingData(id: Int): ByteArray? { try { val db = db.getProxyById(id) if (db == null) { Logger.w(LOG_TAG_PROXY, "$TAG; db is null for id: $id") return null } val cfgFile = File(db.configPath) if (cfgFile.exists()) { Logger.d(LOG_TAG_PROXY, "$TAG; config for $id exists, reading the file") val bytes = EncryptedFileManager.readByteArray(applicationContext, cfgFile) Logger.d(LOG_TAG_PROXY, "$TAG; existing data for $id: ${bytes.size}") return bytes } else { Logger.e(LOG_TAG_PROXY, "$TAG; err; config for $id not found, ${cfgFile.absolutePath}") } } catch (e: Exception) { Logger.w(LOG_TAG_PROXY, "$TAG; err getting existing data for $id: ${e.message}") } return null } suspend fun getSelectedCCs(): Set&lt;String&gt; { return selectedCountries } private suspend fun updateWinConfigToFileAndDb(state: ByteArray): Boolean { // write the win config to the file and update the database // store entitlement in serverResponse column and state in config path column val dir = File( applicationContext.filesDir.absolutePath + File.separator + RPN_PROXY_FOLDER_NAME + File.separator + WIN_NAME.lowercase() + File.separator ) if (!dir.exists()) { Logger.d(LOG_TAG_PROXY, "$TAG; creating dir: ${dir.absolutePath}") dir.mkdirs() } val cfgFile = File(dir, getConfigFileName(WIN_ID)) try { // write the entitlement to the config file val cfgRes = EncryptedFileManager.write(applicationContext, state, cfgFile) Logger.i(LOG_TAG_PROXY, "$TAG writing win config to file: ${cfgFile.absolutePath}") val existingDb = db.getProxyById(WIN_ID) val l = if (existingDb != null) { // if the proxy already exists, update it existingDb.configPath = cfgFile.absolutePath db.update(existingDb) } else { // if the proxy does not exist, insert it val rpnProxy = RpnProxy( id = WIN_ID, name = WIN_NAME, configPath = cfgFile.absolutePath, serverResPath = "", // serverResPath is used to store the entitlement isActive = true, isLockdown = false, createdTs = System.currentTimeMillis(), modifiedTs = System.currentTimeMillis(), misc = "", tunId = "", latency = 0, lastRefreshTime = System.currentTimeMillis() ) db.insert(rpnProxy).toInt() } Logger.d(LOG_TAG_PROXY, "$TAG; win config saved in db? ${l &gt; 0}") if (l &gt; 0 &amp;&amp; cfgRes) { winConfig = state Logger.i(LOG_TAG_PROXY, "$TAG; win config updated") return true } } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; err writing win config to file: ${e.message}", e) } return false } private fun getConfigFileName(id: Int): String { return when (id) { WIN_ID -&gt; WIN_STATE_FILE_NAME else -&gt; "" } } private fun getJsonResponseFileName(id: Int): String { return when (id) { WIN_ID -&gt; WIN_ENTITLEMENT_FILE_NAME else -&gt; "" } } fun canSelectCountryCode(cc: String): Pair&lt;Boolean, String&gt; { // TODO: get country code from win config val isAvailable = false if (!isAvailable) { Logger.i(LOG_TAG_PROXY, "$TAG; cc not available in config: $cc") return Pair(false, "Country code not available in the config") } return if (selectedCountries.size &gt;= 5) { Logger.i(LOG_TAG_PROXY, "$TAG; cc limit reached, selected: ${selectedCountries.size}, $selectedCountries") Pair(false, "Country code limit reached for the selected endpoint") } else { selectedCountries.add(cc) Logger.d(LOG_TAG_PROXY, "$TAG; cc added to selected list: $cc") Pair(true, "") } } fun stats(): String { val sb = StringBuilder() sb.append(" rpnState: ${rpnState().name}\n") sb.append(" rpnMode: ${rpnMode().name}\n") sb.append(" win config? ${winConfig != null}\n") //sb.append(" subscription stats: ${getSubscriptionStatistics()}\n") //sb.append(" current subscription: ${getDetailedSubscriptionInfo()}\n") sb.append(" selected countries: ${selectedCountries.size}, $selectedCountries\n") sb.append(" state machine stats: ${InAppBillingHandler.getConnectionStatusWithStateMachine()}\n") return sb.toString() } /** * Validate the payload received from Play Billing. * The payload is expected to be in the format: "accountId:session_token" * where accountId is the account ID from PipKeyManager and hashkey represents the user * session_token created during the purchase by server */ suspend fun isValidPayload(payload: String): Boolean { if (payload.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; err; payload is empty") return false } val keyState = PipKeyManager.getToken(applicationContext) val keyFromPlayBilling = getCidFromPayload(payload) if (keyState.isEmpty() || keyFromPlayBilling.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; err; key state or key from play billing is empty") return false } if (keyState != keyFromPlayBilling) { Logger.w(LOG_TAG_PROXY, "$TAG; err; key state and key from play billing do not match") return false } Logger.i(LOG_TAG_PROXY, "$TAG; key state and key from play billing match, processing payment") return true } private fun getCidFromPayload(payload: String): String { // sample payload: payload={"ws":{"cid":"aa95f04efcb19a54c7605a02e5dd0b435906b993d12bec031a60f3f1272f4f0e","sessiontoken":"22605:4:1752145272:1da0c248e6cf32ca071a96e477bdf0033368599b4b:307dfd06996672f735409fec4807fcf40a0677e2ef","status":"valid"}} val payloadJson = try { JSONObject(payload) } catch (e: Exception) { Logger.w(LOG_TAG_PROXY, "$TAG; err parsing payload json: ${e.message}") return "" } val ws = payloadJson.optJSONObject("ws") if (ws == null) { Logger.w(LOG_TAG_PROXY, "$TAG; err; ws object is null in payload") return "" } return ws.optString("cid", "") } suspend fun isValidAccountId(accountId: String): Boolean { if (accountId.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; err; accountId is empty") return false } val keyState = PipKeyManager.getToken(applicationContext) if (keyState.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; err; key state is empty") return false } if (keyState != accountId) { Logger.w(LOG_TAG_PROXY, "$TAG; err; key state and accountId do not match") return false } Logger.i(LOG_TAG_PROXY, "$TAG; key state and accountId match, processing payment") return true } suspend fun updateCancelledSubscription(accountId: String, purchaseToken: String): Boolean { if (purchaseToken.isEmpty() || accountId.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; err; purchaseToken is empty") return false } // TODO: perform the validation of purchaseToken and accountId with the subscription data handleUserCancellation() return true } suspend fun getCurrentSubscription(): SubscriptionStateMachineV2.SubscriptionData? { return subscriptionStateMachine.getSubscriptionData() } suspend fun updateRevokedSubscription(accountId: String, purchaseToken: String): Boolean { if (purchaseToken.isEmpty() || accountId.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; err; purchaseToken is empty") return false } handleSubscriptionRevoked() return true } suspend fun fetchAndConstructWinLocations(): Set&lt;RpnWinServer&gt; { // there will be multiple location names for single country code // construct the RpnWinServer object // contains pair RpnProps and errorMsg val winProps = VpnController.getRpnProps(RpnType.WIN).first if (winProps == null) { Logger.w(LOG_TAG_PROXY, "$TAG; err; win props is null") return emptySet() } val count = winProps.locations.len() if (count == 0L) { Logger.w(LOG_TAG_PROXY, "$TAG; err; no locations found in win props") return emptySet() } val servers = mutableSetOf&lt;RpnWinServer&gt;() for( i in 0 until count) { val loc = winProps.locations.get(i) if (loc == null) { Logger.w(LOG_TAG_PROXY, "$TAG; err; location is null at index $i") continue } val prevNames = servers.filter { it.countryCode == loc.cc }.map { it.names }.toMutableList() prevNames.add(loc.name) val newNames = prevNames.distinct().sorted().joinToString { "," } // each cc will have multiple locations // add that to the list of servers val s = RpnWinServer(newNames, loc.cc, loc.addrs, true) servers.add(s) } // assign it to winServers return servers } suspend fun processRpnPurchase(purchase: PurchaseDetail?, existingSubs: SubscriptionStatus): Boolean { if (purchase == null) { Logger.w(LOG_TAG_PROXY, "$TAG; err; no purchases to process") try { subscriptionStateMachine.subscriptionExpired() } catch (e: Exception) { Logger.e( LOG_TAG_PROXY, "$TAG; error notifying state machine of expiration: ${e.message}", e ) } return false } if (purchase.productId.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; err; productId is empty for purchase: $purchase") try { subscriptionStateMachine.purchaseFailed("Empty product ID", null) } catch (e: Exception) { Logger.e( LOG_TAG_PROXY, "$TAG; error notifying state machine of purchase failure: ${e.message}", e ) } return false } // Enhanced validation if (!isValidPayload(purchase.payload) &amp;&amp; !isValidAccountId(purchase.accountId)) { Logger.w( LOG_TAG_PROXY, "$TAG; err; invalid payload or account ID for purchase: $purchase" ) try { subscriptionStateMachine.purchaseFailed( "Invalid payload or account ID", null ) } catch (e: Exception) { Logger.e( LOG_TAG_PROXY, "$TAG; error notifying state machine of validation failure: ${e.message}", e ) } return false } val accExpiry = existingSubs.accountExpiry val billingExpiry = existingSubs.billingExpiry val currTs = System.currentTimeMillis() if (billingExpiry &gt; currTs) { Logger.d(LOG_TAG_PROXY, "$TAG; existing subscription is still valid, no immediate action needed") } if (accExpiry &gt; currTs) { Logger.d(LOG_TAG_PROXY, "$TAG; existing account is still valid, no immediate action needed") } // in case if the account expiry is less than the billing expiry, query the entitlement // from server and update the subscription state machine // Check if the billing expiry + 1 day is greater than the account expiry. // there is always a delay so just add 1 more day to the billing expiry val oneDay = 24 * 60 * 60 * 1000 // 1 day in milliseconds if (accExpiry &lt; billingExpiry + oneDay ) { Logger.d(LOG_TAG_PROXY, "$TAG; account expiry is less than billing expiry, querying entitlement") try { val developerPayload = InAppBillingHandler.queryEntitlementFromServer(purchase.accountId) if (developerPayload != null &amp;&amp; developerPayload.isNotEmpty()) { Logger.i(LOG_TAG_PROXY, "$TAG; developer payload received for ${purchase.productId}") activateRpn(purchase, developerPayload) val newPurchase = purchase.copy(payload = developerPayload) val subsData = subscriptionStateMachine.getSubscriptionData() if (subsData != null) { subsData.subscriptionStatus.developerPayload = newPurchase.payload subsData.purchaseDetail?.copy(payload = developerPayload) subscriptionStateMachine.stateMachine.updateData(subsData) } } } catch (e: Exception) { Logger.w(LOG_TAG_PROXY, "$TAG; error querying entitlement: ${e.message}") } } // activate the RPN activateRpn(purchase) return true } private fun startStateObserver() { stateObserverScope.launch { try { subscriptionStateMachine.currentState.collect { state -&gt; Logger.d(LOG_TAG_PROXY, "$TAG; collect; initial subscription state: ${state.name}") io { handleStateChange(state) } } } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; collect; error in state observer: ${e.message}", e) } } } private suspend fun handleStateChange(state: SubscriptionStateMachineV2.SubscriptionState) { when (state) { is SubscriptionStateMachineV2.SubscriptionState.Active -&gt; { Logger.i( LOG_TAG_PROXY, "$TAG; subscription activated, ensuring RPN is enabled if configured" ) // Could potentially auto-enable RPN if conditions are met if (!isRpnEnabled()) { val subs = subscriptionStateMachine.getSubscriptionData() val purchaseDetail = subs?.purchaseDetail if (purchaseDetail == null) { // this should not happen Logger.w(LOG_TAG_PROXY, "$TAG; no purchase detail available for activation, but state is active") return } activateRpn(purchaseDetail) } } is SubscriptionStateMachineV2.SubscriptionState.Cancelled -&gt; { Logger.i(LOG_TAG_PROXY, "$TAG; subscription cancelled, disabling RPN if active") val subs = subscriptionStateMachine.getSubscriptionData() val status = subs?.subscriptionStatus val currTs = System.currentTimeMillis() if ((status != null &amp;&amp; status.billingExpiry &gt; currTs) || DEBUG) { deactivateRpn("Subscription cancelled") } else { Logger.w(LOG_TAG_PROXY, "$TAG; subscription cancelled but still valid, not deactivating RPN") } } is SubscriptionStateMachineV2.SubscriptionState.Expired -&gt; { Logger.w(LOG_TAG_PROXY, "$TAG; subscription expired, disabling RPN") deactivateRpn("Subscription expired") } is SubscriptionStateMachineV2.SubscriptionState.Revoked -&gt; { Logger.w(LOG_TAG_PROXY, "$TAG; subscription revoked, immediately disabling RPN") deactivateRpn("Subscription revoked") } is SubscriptionStateMachineV2.SubscriptionState.Error -&gt; { Logger.e(LOG_TAG_PROXY, "$TAG; subscription state machine in error state") // Could implement error recovery logic here } else -&gt; { Logger.d(LOG_TAG_PROXY, "$TAG; subscription state: ${state.name}") } } } fun collectSubscriptionState(): Flow&lt;SubscriptionStateMachineV2.SubscriptionState&gt; { return subscriptionStateMachine.currentState } fun getSubscriptionState(): SubscriptionStateMachineV2.SubscriptionState { return subscriptionStateMachine.getCurrentState() } fun getSubscriptionData(): SubscriptionStateMachineV2.SubscriptionData? { return subscriptionStateMachine.getSubscriptionData() } fun canMakePurchase(): Boolean { return subscriptionStateMachine.canMakePurchase() } fun hasValidSubscription(): Boolean { if (DEBUG) { persistentState.rpnState = RpnState.ENABLED.id return true // temporarily always return true } val valid = subscriptionStateMachine.hasValidSubscription() Logger.i(LOG_TAG_PROXY, "$TAG; using state machine for subscription check, valid: $valid") return valid } fun isSubscriptionActiveInStateMachine(): Boolean { return subscriptionStateMachine.isSubscriptionActive() } suspend fun handleSubscriptionRestored(purchaseDetail: PurchaseDetail) { try { subscriptionStateMachine.restoreSubscription(purchaseDetail) Logger.i(LOG_TAG_PROXY, "$TAG; subscription restored: ${purchaseDetail.productId}") } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error restoring subscription: ${e.message}", e) } } suspend fun handleUserCancellation() { try { subscriptionStateMachine.userCancelled() Logger.i(LOG_TAG_PROXY, "$TAG; user cancellation handled") } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error handling user cancellation: ${e.message}", e) } } suspend fun handleSubscriptionRevoked() { try { subscriptionStateMachine.subscriptionRevoked() Logger.w(LOG_TAG_PROXY, "$TAG; subscription revocation handled") // Immediately deactivate RPN deactivateRpn() Logger.i(LOG_TAG_PROXY, "$TAG; RPN deactivated due to revocation") } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error handling subscription revocation: ${e.message}", e) } } suspend fun performSystemCheck() { try { subscriptionStateMachine.systemCheck() Logger.d(LOG_TAG_PROXY, "$TAG; system check performed") } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error during system check: ${e.message}", e) } } fun getSubscriptionStatistics(): StateMachineStatistics? { return subscriptionStateMachine.getStatistics() } fun cleanup() { try { stateObserverJob.cancel() Logger.i(LOG_TAG_PROXY, "$TAG; subscription state machine integration cleaned up") } catch (e: Exception) { Logger.e(LOG_TAG_PROXY, "$TAG; error during cleanup: ${e.message}", e) } } private fun isValidForRpnActivation(purchase: PurchaseDetail): Boolean { // Check basic purchase validity if (purchase.productId.isEmpty()) { Logger.w(LOG_TAG_PROXY, "$TAG; invalid purchase - empty product ID") return false } // Check if purchase is revoked if (purchase.status == SubscriptionStatus.SubscriptionState.STATE_REVOKED.id) { Logger.w(LOG_TAG_PROXY, "$TAG; invalid purchase - revoked status") return false } // Check if purchase is expired if (purchase.expiryTime &gt; 0 &amp;&amp; System.currentTimeMillis() &gt; purchase.expiryTime) { Logger.w(LOG_TAG_PROXY, "$TAG; invalid purchase - expired") return false } // Check state machine state if available val currentState = subscriptionStateMachine.getCurrentState() when (currentState) { is SubscriptionStateMachineV2.SubscriptionState.Revoked, is SubscriptionStateMachineV2.SubscriptionState.Expired -&gt; { Logger.w( LOG_TAG_PROXY, "$TAG; invalid for activation - state machine in ${currentState.name}" ) return false } else -&gt; { // Other states are potentially valid } } return true } fun isRpnValidForCurrentSubscription(): Boolean { if (!isRpnEnabled()) { return false } val currentState = subscriptionStateMachine.getCurrentState() when (currentState) { is SubscriptionStateMachineV2.SubscriptionState.Active, is SubscriptionStateMachineV2.SubscriptionState.Cancelled -&gt; { Logger.i( LOG_TAG_PROXY, "$TAG; RPN is valid for current subscription state: ${currentState.name}" ) return true } is SubscriptionStateMachineV2.SubscriptionState.Revoked, is SubscriptionStateMachineV2.SubscriptionState.Expired -&gt; { Logger.w( LOG_TAG_PROXY, "$TAG; RPN should be disabled - subscription ${currentState.name}" ) return false } else -&gt; { Logger.d( LOG_TAG_PROXY, "$TAG; RPN validity uncertain for state: ${currentState.name}" ) return true // Allow by default for uncertain states } } } fun getDetailedSubscriptionInfo(): String { val statistics = subscriptionStateMachine.getStatistics() val subscriptionData = subscriptionStateMachine.getSubscriptionData() val currentState = subscriptionStateMachine.getCurrentState() return """ Current State: ${currentState.name} RPN Enabled: ${isRpnEnabled()} RPN Valid: ${isRpnValidForCurrentSubscription()} Total Transitions: ${statistics.totalTransitions} Success Rate: ${String.format("%.2f", statistics.successRate * 100)}% Product ID: ${subscriptionData?.subscriptionStatus?.productId ?: "None"} Subscription Status: ${subscriptionData?.subscriptionStatus?.status?.let { SubscriptionStatus.SubscriptionState.fromId(it).name } ?: "Unknown"} Billing Expiry: ${subscriptionData?.subscriptionStatus?.billingExpiry?.let { if (it &gt; 0) java.util.Date(it) else "N/A" } ?: "N/A"} Account Expiry: ${subscriptionData?.subscriptionStatus?.accountExpiry?.let { if (it &gt; 0) java.util.Date(it) else "N/A" } ?: "N/A"} """.trimIndent() } private fun io(f: suspend () -&gt; Unit) { CoroutineScope(Dispatchers.IO).launch { f() } } } */</ID>
    <ID>ForbiddenComment:SubscriptionStateMachineV2.kt$/* import Logger.LOG_IAB import com.android.billingclient.api.BillingClient import com.android.billingclient.api.BillingResult import com.android.billingclient.api.Purchase import com.celzero.bravedns.database.SubscriptionStatus import com.celzero.bravedns.database.SubscriptionStatusRepository import com.celzero.bravedns.iab.PurchaseDetail import com.celzero.bravedns.rpnproxy.RpnProxyManager import com.celzero.bravedns.util.Constants import com.celzero.bravedns.util.Utilities import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.SupervisorJob import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.launch import org.koin.core.component.KoinComponent import org.koin.core.component.inject /** * Subscription State Machine using the framework * This demonstrates how to use the generic state machine framework * for managing subscription states with proper error handling and RPN integration */ class SubscriptionStateMachineV2 : KoinComponent { private val subscriptionDb by inject&lt;SubscriptionStatusRepository&gt;() private val dbSyncService: StateMachineDatabaseSyncService by inject() private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO) var stateMachine: StateMachine&lt;SubscriptionState, SubscriptionEvent, SubscriptionData&gt; companion object { private const val TAG = "SubscriptionStateMachineV2" } init { stateMachine = createStateMachine&lt;SubscriptionState, SubscriptionEvent, SubscriptionData&gt;( initialState = SubscriptionState.Uninitialized, tag = TAG ) { // Initialize transition addTransition( fromState = SubscriptionState.Uninitialized, event = SubscriptionEvent.Initialize, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleInitialize() } ) // initial state can be from Uninitialized or Initial to active/on-hold/expired/revoked addTransition( fromState = SubscriptionState.Initial, event = SubscriptionEvent.Initialize, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleInitialize() } ) // initial state to cancelled state addTransition( fromState = SubscriptionState.Initial, event = SubscriptionEvent.UserCancelled, toState = SubscriptionState.Cancelled, action = { _, data -&gt; handleUserCancelled(data as? SubscriptionData) } ) // initial state to error state addTransition( fromState = SubscriptionState.Initial, event = SubscriptionEvent.BillingError("", BillingResult.newBuilder().build()), toState = SubscriptionState.Error, guard = { event, _ -&gt; event is SubscriptionEvent.BillingError }, action = { event, _ -&gt; val errorEvent = event as SubscriptionEvent.BillingError handleBillingError(errorEvent.error, errorEvent.billingResult) } ) // initial state to expired state addTransition( fromState = SubscriptionState.Initial, event = SubscriptionEvent.SubscriptionExpired, toState = SubscriptionState.Expired, action = { _, data -&gt; handleSubscriptionExpired(data as? SubscriptionData) } ) // Purchase flow transitions addTransition( fromState = SubscriptionState.Initial, event = SubscriptionEvent.PurchaseInitiated, toState = SubscriptionState.PurchaseInitiated ) // Add missing PaymentSuccessful transition from Initial state // This handles cases where payment is processed directly from initial state addTransition( fromState = SubscriptionState.Initial, event = SubscriptionEvent.PaymentSuccessful(createDummyPurchaseDetail()), toState = SubscriptionState.Active, guard = { event, _ -&gt; event is SubscriptionEvent.PaymentSuccessful }, action = { event, _ -&gt; val paymentEvent = event as SubscriptionEvent.PaymentSuccessful handlePaymentSuccessful(paymentEvent.purchaseDetail) } ) // Error recovery transitions addTransition( fromState = SubscriptionState.Error, event = SubscriptionEvent.ErrorRecovered, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleErrorRecovery() } ) addTransition( fromState = SubscriptionState.Error, event = SubscriptionEvent.SystemCheck, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleSystemCheck() } ) // Purchase completion transitions - FIXED: Direct event matching addTransition( fromState = SubscriptionState.PurchaseInitiated, event = SubscriptionEvent.PurchaseCompleted(createDummyPurchaseDetail()), toState = SubscriptionState.PurchasePending, guard = { event, _ -&gt; event is SubscriptionEvent.PurchaseCompleted }, action = { event, _ -&gt; val purchaseEvent = event as SubscriptionEvent.PurchaseCompleted handlePurchaseCompleted(purchaseEvent.purchaseDetail) } ) addTransition( fromState = SubscriptionState.PurchaseInitiated, event = SubscriptionEvent.PaymentSuccessful(createDummyPurchaseDetail()), toState = SubscriptionState.Active, guard = { event, _ -&gt; event is SubscriptionEvent.PaymentSuccessful }, action = { event, _ -&gt; val paymentEvent = event as SubscriptionEvent.PaymentSuccessful handlePaymentSuccessful(paymentEvent.purchaseDetail) } ) // FIXED: Add missing UserCancelled transition from PurchaseInitiated state addTransition( fromState = SubscriptionState.PurchaseInitiated, event = SubscriptionEvent.UserCancelled, toState = SubscriptionState.Initial, action = { _, data -&gt; handleUserCancelledFromPurchase(data as? SubscriptionData) } ) // FIXED: Add missing UserCancelled transition from PurchasePending state addTransition( fromState = SubscriptionState.PurchasePending, event = SubscriptionEvent.UserCancelled, toState = SubscriptionState.Initial, action = { _, data -&gt; handleUserCancelledFromPurchase(data as? SubscriptionData) } ) // Failure transitions - FIXED addTransition( fromState = SubscriptionState.PurchaseInitiated, event = SubscriptionEvent.PurchaseFailed("", null), toState = SubscriptionState.Error, guard = { event, _ -&gt; event is SubscriptionEvent.PurchaseFailed }, action = { event, _ -&gt; val failureEvent = event as SubscriptionEvent.PurchaseFailed handlePurchaseFailed(failureEvent.error, failureEvent.billingResult) } ) // Payment successful transition from pending addTransition( fromState = SubscriptionState.PurchasePending, event = SubscriptionEvent.PaymentSuccessful(createDummyPurchaseDetail()), toState = SubscriptionState.Active, guard = { event, _ -&gt; event is SubscriptionEvent.PaymentSuccessful }, action = { event, _ -&gt; val paymentEvent = event as SubscriptionEvent.PaymentSuccessful handlePaymentSuccessful(paymentEvent.purchaseDetail) } ) // Active state transitions addTransition( fromState = SubscriptionState.Active, event = SubscriptionEvent.UserCancelled, toState = SubscriptionState.Cancelled, action = { _, data -&gt; handleUserCancelled(data as? SubscriptionData) } ) addTransition( fromState = SubscriptionState.Active, event = SubscriptionEvent.SubscriptionExpired, toState = SubscriptionState.Expired, action = { _, data -&gt; handleSubscriptionExpired(data as? SubscriptionData) } ) addTransition( fromState = SubscriptionState.Active, event = SubscriptionEvent.SubscriptionRevoked, toState = SubscriptionState.Revoked, action = { _, data -&gt; handleSubscriptionRevoked(data as? SubscriptionData) } ) // Cancelled state transitions - FIXED addTransition( fromState = SubscriptionState.Cancelled, event = SubscriptionEvent.SubscriptionExpired, toState = SubscriptionState.Expired, action = { _, data -&gt; handleSubscriptionExpired(data as? SubscriptionData) } ) /*addTransition( fromState = SubscriptionState.Cancelled, event = SubscriptionEvent.PaymentSuccessful(createDummyPurchaseDetail()), toState = SubscriptionState.Active, guard = { event, _ -&gt; event is SubscriptionEvent.PaymentSuccessful }, action = { event, _ -&gt; val paymentEvent = event as SubscriptionEvent.PaymentSuccessful handlePaymentSuccessful(paymentEvent.purchaseDetail) } )*/ addTransition( fromState = SubscriptionState.Cancelled, event = SubscriptionEvent.SubscriptionRevoked, toState = SubscriptionState.Revoked, action = { _, data -&gt; handleSubscriptionRevoked(data as? SubscriptionData) } ) // Expired state transitions - FIXED addTransition( fromState = SubscriptionState.Expired, event = SubscriptionEvent.PurchaseInitiated, toState = SubscriptionState.PurchaseInitiated ) addTransition( fromState = SubscriptionState.Expired, event = SubscriptionEvent.SubscriptionRestored(createDummyPurchaseDetail()), toState = SubscriptionState.Active, guard = { event, _ -&gt; event is SubscriptionEvent.SubscriptionRestored }, action = { event, _ -&gt; val restoreEvent = event as SubscriptionEvent.SubscriptionRestored handleSubscriptionRestored(restoreEvent.purchaseDetail) } ) // Revoked state transitions - FIXED addTransition( fromState = SubscriptionState.Revoked, event = SubscriptionEvent.PurchaseInitiated, toState = SubscriptionState.PurchaseInitiated ) addTransition( fromState = SubscriptionState.Revoked, event = SubscriptionEvent.SubscriptionRestored(createDummyPurchaseDetail()), toState = SubscriptionState.Active, guard = { event, _ -&gt; event is SubscriptionEvent.SubscriptionRestored }, action = { event, _ -&gt; val restoreEvent = event as SubscriptionEvent.SubscriptionRestored handleSubscriptionRestored(restoreEvent.purchaseDetail) } ) // System transitions from any state addTransition( fromState = SubscriptionState.Initial, event = SubscriptionEvent.SystemCheck, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleSystemCheck() } ) addTransition( fromState = SubscriptionState.Active, event = SubscriptionEvent.PaymentSuccessful(createDummyPurchaseDetail()), toState = SubscriptionState.Active, guard = { event, _ -&gt; event is SubscriptionEvent.PaymentSuccessful }, action = { event, _ -&gt; val paymentEvent = event as SubscriptionEvent.PaymentSuccessful handlePaymentSuccessful(paymentEvent.purchaseDetail) } ) // Error transitions from any problematic state - FIXED addTransition( fromState = SubscriptionState.PurchaseInitiated, event = SubscriptionEvent.BillingError("", BillingResult.newBuilder().build()), toState = SubscriptionState.Error, guard = { event, _ -&gt; event is SubscriptionEvent.BillingError }, action = { event, _ -&gt; val errorEvent = event as SubscriptionEvent.BillingError handleBillingError(errorEvent.error, errorEvent.billingResult) } ) addTransition( fromState = SubscriptionState.PurchasePending, event = SubscriptionEvent.BillingError("", BillingResult.newBuilder().build()), toState = SubscriptionState.Error, guard = { event, _ -&gt; event is SubscriptionEvent.BillingError }, action = { event, _ -&gt; val errorEvent = event as SubscriptionEvent.BillingError handleBillingError(errorEvent.error, errorEvent.billingResult) } ) addTransition( fromState = SubscriptionState.Active, event = SubscriptionEvent.DatabaseError(""), toState = SubscriptionState.Error, guard = { event, _ -&gt; event is SubscriptionEvent.DatabaseError }, action = { event, _ -&gt; val errorEvent = event as SubscriptionEvent.DatabaseError handleDatabaseError(errorEvent.error) } ) // handle state from cancelled state to initial state addTransition( fromState = SubscriptionState.Cancelled, event = SubscriptionEvent.SystemCheck, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleSystemCheck() } ) addTransition( fromState = SubscriptionState.Expired, event = SubscriptionEvent.SystemCheck, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleSystemCheck() } ) addTransition( fromState = SubscriptionState.Revoked, event = SubscriptionEvent.SystemCheck, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleSystemCheck() } ) // handle state from error state to payment initiated state addTransition( fromState = SubscriptionState.Error, event = SubscriptionEvent.PurchaseInitiated, toState = SubscriptionState.PurchaseInitiated, action = { _, _ -&gt; handleSystemCheck() } ) addTransition( fromState = SubscriptionState.Error, event = SubscriptionEvent.SystemCheck, toState = SubscriptionState.Initial, action = { _, _ -&gt; handleSystemCheck() } ) // handle state from cancelled state to purchase initiated state addTransition( fromState = SubscriptionState.Cancelled, event = SubscriptionEvent.PurchaseInitiated, toState = SubscriptionState.PurchaseInitiated, action = { _, _ -&gt; handleSystemCheck() } ) addTransition( fromState = SubscriptionState.Expired, event = SubscriptionEvent.PurchaseInitiated, toState = SubscriptionState.PurchaseInitiated, action = { _, _ -&gt; handleSystemCheck() } ) addTransition( fromState = SubscriptionState.Revoked, event = SubscriptionEvent.PurchaseInitiated, toState = SubscriptionState.PurchaseInitiated, action = { _, _ -&gt; handleSystemCheck() } ) // Event handlers onStateChanged { fromState, toState, event -&gt; Logger.i( LOG_IAB, "$TAG: State changed from ${fromState.name} to ${toState.name} on event ${event.name}" ) } onTransitionFailed { fromState, event, error -&gt; Logger.e( LOG_IAB, "$TAG: Transition failed from ${fromState.name} on event ${event.name}: $error" ) } onInvalidTransition { fromState, event -&gt; Logger.w( LOG_IAB, "$TAG: Invalid transition attempted from ${fromState.name} on event ${event.name}" ) } } Logger.i(LOG_IAB, "$TAG: Initializing SubscriptionStateMachineV2") initializeStateMachine() Logger.i(LOG_IAB, "$TAG: SubscriptionStateMachineV2 initialized") } // Define states sealed class SubscriptionState : State { object Uninitialized : SubscriptionState() object Initial : SubscriptionState() object PurchaseInitiated : SubscriptionState() object PurchasePending : SubscriptionState() object Active : SubscriptionState() object Cancelled : SubscriptionState() object Expired : SubscriptionState() object Revoked : SubscriptionState() object Error : SubscriptionState() val isActive: Boolean get() = this is Active val canMakePurchase: Boolean get() = this is Initial || this is Expired || this is Revoked || this is Cancelled || this is Error || this is PurchaseInitiated || this is PurchasePending val hasValidSubscription: Boolean get() = this is Active val isCancelled: Boolean get() = this is Cancelled val isRevoked: Boolean get() = this is Revoked val isExpired: Boolean get() = this is Expired fun state(): SubscriptionState { return when (this) { is Uninitialized -&gt; Initial is Initial -&gt; this is PurchaseInitiated -&gt; this is PurchasePending -&gt; this is Active -&gt; this is Cancelled -&gt; this is Expired -&gt; this is Revoked -&gt; this is Error -&gt; this } } } // Define events sealed class SubscriptionEvent : Event { object Initialize : SubscriptionEvent() object PurchaseInitiated : SubscriptionEvent() data class PurchaseCompleted(val purchaseDetail: PurchaseDetail) : SubscriptionEvent() data class PurchaseFailed(val error: String, val billingResult: BillingResult? = null) : SubscriptionEvent() data class PaymentSuccessful(val purchaseDetail: PurchaseDetail) : SubscriptionEvent() object UserCancelled : SubscriptionEvent() object SubscriptionExpired : SubscriptionEvent() object SubscriptionRevoked : SubscriptionEvent() data class SubscriptionRestored(val purchaseDetail: PurchaseDetail) : SubscriptionEvent() object SystemCheck : SubscriptionEvent() data class BillingError(val error: String, val billingResult: BillingResult) : SubscriptionEvent() data class DatabaseError(val error: String) : SubscriptionEvent() object ErrorRecovered : SubscriptionEvent() } // Define data data class SubscriptionData( val subscriptionStatus: SubscriptionStatus, val purchaseDetail: PurchaseDetail? = null, val lastUpdated: Long = System.currentTimeMillis() ) val currentState: StateFlow&lt;SubscriptionState&gt; = stateMachine.currentState private fun initializeStateMachine() { io { initialize() handleSystemCheckAndDatabaseRestoration() // Add missing Flow properties for reactive state observation currentState.to(stateMachine.currentState) } } // Helper function to create dummy purchase detail for event matching private fun createDummyPurchaseDetail(): PurchaseDetail { return PurchaseDetail( productId = "", planId = "", productTitle = "", state = Purchase.PurchaseState.PURCHASED, planTitle = "", purchaseToken = "", productType = com.android.billingclient.api.BillingClient.ProductType.SUBS, purchaseTime = "", purchaseTimeMillis = 0L, isAutoRenewing = false, accountId = "", payload = "", expiryTime = 0L, status = Purchase.PurchaseState.PURCHASED ) } suspend fun initialize() { Logger.i(LOG_IAB, "$TAG: Initializing subscription state machine") stateMachine.processEvent(SubscriptionEvent.Initialize) Logger.i(LOG_IAB, "$TAG: Subscription state machine initialized") } suspend fun startPurchase() { stateMachine.processEvent(SubscriptionEvent.PurchaseInitiated) } suspend fun completePurchase(purchaseDetail: PurchaseDetail) { stateMachine.processEvent(SubscriptionEvent.PurchaseCompleted(purchaseDetail)) } suspend fun paymentSuccessful(purchaseDetail: PurchaseDetail) { stateMachine.processEvent(SubscriptionEvent.PaymentSuccessful(purchaseDetail)) } suspend fun purchaseFailed(error: String, billingResult: BillingResult? = null) { stateMachine.processEvent(SubscriptionEvent.PurchaseFailed(error, billingResult)) } suspend fun userCancelled() { stateMachine.processEvent(SubscriptionEvent.UserCancelled) } suspend fun subscriptionExpired() { stateMachine.processEvent(SubscriptionEvent.SubscriptionExpired) } suspend fun subscriptionRevoked() { stateMachine.processEvent(SubscriptionEvent.SubscriptionRevoked) } suspend fun restoreSubscription(purchaseDetail: PurchaseDetail) { stateMachine.processEvent(SubscriptionEvent.SubscriptionRestored(purchaseDetail)) } suspend fun systemCheck() { stateMachine.processEvent(SubscriptionEvent.SystemCheck) } fun getCurrentState(): SubscriptionState = stateMachine.getCurrentState() fun getSubscriptionData(): SubscriptionData? = stateMachine.getCurrentData() fun canMakePurchase(): Boolean = stateMachine.getCurrentState().canMakePurchase fun hasValidSubscription(): Boolean = stateMachine.getCurrentState().hasValidSubscription fun isSubscriptionActive(): Boolean = stateMachine.getCurrentState().isActive fun getStatistics(): StateMachineStatistics = stateMachine.getStatistics() // Action handlers private suspend fun handleInitialize() { try { Logger.i(LOG_IAB, "$TAG: ***Initializing subscription state machine***") // Load state from database /*val dbStateInfo = dbSyncService.loadStateFromDatabase() Logger.i(LOG_IAB, "$TAG: Loaded state from database: $dbStateInfo") if (dbStateInfo != null) { Logger.d(LOG_IAB, "$TAG: Found database state: ${dbStateInfo.recommendedState.name} for subscription: ${dbStateInfo.currentSubscription.productId}") val subscriptionData = SubscriptionData(subscriptionStatus = dbStateInfo.currentSubscription) stateMachine.updateData(subscriptionData) // Directly transition to the recommended state from database stateMachine.directTransitionTo(dbStateInfo.recommendedState) stateMachine.processEvent(dbStateInfo.recommendedState) Logger.i(LOG_IAB, "$TAG: State machine initialized with state: ${stateMachine.getCurrentState().name}") } else { Logger.d(LOG_IAB, "$TAG: No existing subscription data found in database - staying in Initial state") // Transition from Uninitialized to Initial stateMachine.directTransitionTo(SubscriptionState.Initial) }*/ } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error during initialization: ${e.message}", e) // Continue with initial state on error //stateMachine.directTransitionTo(SubscriptionState.Initial) } } private suspend fun handlePurchaseCompleted(purchaseDetail: PurchaseDetail) { try { Logger.i(LOG_IAB, "$TAG: Handling purchase completed: ${purchaseDetail.productId}") // Save purchase detail to database (handles duplicates properly) val subscriptionId = dbSyncService.savePurchaseDetail(purchaseDetail) Logger.d(LOG_IAB, "$TAG: Purchase detail saved/updated with ID: $subscriptionId") if (subscriptionId &gt; 0) { // Create subscription data with the correct ID val subscriptionStatus = convertPurchaseDetailToSubscriptionStatus(purchaseDetail, subscriptionId) val subscriptionData = SubscriptionData( subscriptionStatus = subscriptionStatus, purchaseDetail = purchaseDetail ) stateMachine.updateData(subscriptionData) // FIXED: Save state transition history dbSyncService.saveStateTransition( fromState = stateMachine.getCurrentState(), // Use actual current state toState = SubscriptionState.PurchasePending, // Transition to pending subscriptionData = subscriptionData, reason = "Purchase completed, awaiting acknowledgment" ) Logger.i(LOG_IAB, "$TAG: Purchase completed and saved to database with history") } else { Logger.e(LOG_IAB, "$TAG: Failed to save purchase detail") } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling purchase completed: ${e.message}", e) } } // Helper function to convert PurchaseDetail to SubscriptionStatus private fun convertPurchaseDetailToSubscriptionStatus( purchaseDetail: PurchaseDetail, subscriptionId: Long ): SubscriptionStatus { val accExpiry = RpnProxyManager.getExpiryFromPayload(purchaseDetail.payload) ?: purchaseDetail.expiryTime val subscriptionStatus = SubscriptionStatus() subscriptionStatus.id = subscriptionId.toInt() subscriptionStatus.accountId = purchaseDetail.accountId subscriptionStatus.purchaseToken = purchaseDetail.purchaseToken subscriptionStatus.productId = purchaseDetail.productId subscriptionStatus.planId = purchaseDetail.planId subscriptionStatus.productTitle = purchaseDetail.productTitle subscriptionStatus.state = purchaseDetail.state subscriptionStatus.purchaseTime = purchaseDetail.purchaseTimeMillis subscriptionStatus.billingExpiry = purchaseDetail.expiryTime subscriptionStatus.accountExpiry = accExpiry subscriptionStatus.developerPayload = purchaseDetail.payload subscriptionStatus.status = purchaseDetail.status subscriptionStatus.lastUpdatedTs = System.currentTimeMillis() return subscriptionStatus } private fun createPurchaseDetailFromSubscription(subscriptionStatus: SubscriptionStatus): PurchaseDetail { return PurchaseDetail( productId = subscriptionStatus.productId, planId = subscriptionStatus.planId, productTitle = subscriptionStatus.productTitle, state = subscriptionStatus.state, planTitle = subscriptionStatus.productTitle, purchaseToken = subscriptionStatus.purchaseToken, productType = BillingClient.ProductType.SUBS, purchaseTime = Utilities.convertLongToTime( subscriptionStatus.purchaseTime, Constants.TIME_FORMAT_4 ), purchaseTimeMillis = subscriptionStatus.purchaseTime, isAutoRenewing = true, // Default for subscriptions accountId = subscriptionStatus.accountId, payload = subscriptionStatus.developerPayload, expiryTime = subscriptionStatus.billingExpiry, status = subscriptionStatus.status ) } // not a valid state transition, but makes an entry in the database for maintaining history private suspend fun handlePurchaseFailed(error: String, billingResult: BillingResult?) { try { Logger.e(LOG_IAB, "$TAG: Handling purchase failed: $error") // put an entry in the database history as purchase failed dbSyncService.savePurchaseFailureHistory(error, billingResult) Logger.i(LOG_IAB, "$TAG: Purchase failure handled") } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling purchase failure: ${e.message}", e) } } private suspend fun handlePaymentSuccessful(purchaseDetail: PurchaseDetail) { try { Logger.i(LOG_IAB, "$TAG: Handling payment successful: ${purchaseDetail.productId}") // Get existing subscription instead of creating new one val existingSubscription = getCurrentSubscriptionStatus(purchaseDetail) if (existingSubscription != null) { // Update existing subscription to active val accExpiry = RpnProxyManager.getExpiryFromPayload(purchaseDetail.payload) ?: purchaseDetail.expiryTime existingSubscription.status = SubscriptionStatus.SubscriptionState.STATE_ACTIVE.id existingSubscription.billingExpiry = purchaseDetail.expiryTime existingSubscription.accountExpiry = accExpiry existingSubscription.sessionToken = RpnProxyManager.getSessionTokenFromPayload(purchaseDetail.payload) existingSubscription.developerPayload = purchaseDetail.payload val updateResult = subscriptionDb.upsert(existingSubscription) if (updateResult &gt; 0) { // Update state machine data val subscriptionData = SubscriptionData( subscriptionStatus = existingSubscription, purchaseDetail = purchaseDetail ) stateMachine.updateData(subscriptionData) // FIXED: Use actual current state instead of hardcoded fromState val currentState = stateMachine.getCurrentState() dbSyncService.saveStateTransition( fromState = currentState, // Use actual current state toState = SubscriptionState.Active, subscriptionData = subscriptionData, reason = "Payment successful from ${currentState.name}" ) // Activate RPN if needed scope.launch { try { val res = RpnProxyManager.processRpnPurchase( purchaseDetail, existingSubscription ) Logger.d( LOG_IAB, "$TAG: RPN activated? $res for purchase: ${purchaseDetail.productId}" ) } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: err activating RPN: ${e.message}", e) } } Logger.i( LOG_IAB, "$TAG: Payment successful handled from state: ${currentState.name}" ) } else { Logger.e(LOG_IAB, "$TAG: Failed to update subscription status") } } else { Logger.e(LOG_IAB, "$TAG: No existing subscription found for payment") } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: err handling payment successful: ${e.message}", e) } } private suspend fun handleUserCancelled(data: SubscriptionData?) { try { Logger.i(LOG_IAB, "$TAG: Handling user cancellation") data?.let { subscriptionData -&gt; subscriptionData.subscriptionStatus.status = SubscriptionStatus.SubscriptionState.STATE_CANCELLED.id val updateResult = subscriptionDb.upsert(subscriptionData.subscriptionStatus) if (updateResult &gt; 0) { // Update state machine data val updatedData = subscriptionData.copy(subscriptionStatus = subscriptionData.subscriptionStatus) stateMachine.updateData(updatedData) // Save state transition dbSyncService.saveStateTransition( fromState = SubscriptionState.Active, toState = SubscriptionState.Cancelled, subscriptionData = updatedData, reason = "User cancelled subscription" ) Logger.i(LOG_IAB, "$TAG: User cancellation handled") } else { Logger.e(LOG_IAB, "$TAG: Failed to update subscription for cancellation") } } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling user cancellation: ${e.message}", e) } } private suspend fun handleUserCancelledFromPurchase(data: SubscriptionData?) { try { Logger.i(LOG_IAB, "$TAG: Handling user cancellation from purchase flow") // For cancellations during purchase flow, we don't need to update any subscription // status since the purchase never completed. Just log the cancellation. Logger.i(LOG_IAB, "$TAG: User cancelled purchase flow - returning to initial state") // Optionally save this event for analytics data?.let { subscriptionData -&gt; dbSyncService.saveStateTransition( fromState = SubscriptionState.PurchaseInitiated, toState = SubscriptionState.Initial, subscriptionData = subscriptionData, reason = "User cancelled purchase flow" ) } } catch (e: Exception) { Logger.e( LOG_IAB, "$TAG: Error handling user cancellation from purchase: ${e.message}", e ) } } private suspend fun handleSystemCheckAndDatabaseRestoration() { try { Logger.i(LOG_IAB, "$TAG: Performing system check and database restoration") // First perform system check val isRpnActive = RpnProxyManager.isRpnActive() Logger.i(LOG_IAB, "$TAG: RPN active status: $isRpnActive") // Then check for database state restoration val dbStateInfo = dbSyncService.loadStateFromDatabase() if (dbStateInfo != null) { Logger.i( LOG_IAB, "$TAG: Found database state: ${dbStateInfo.recommendedState.name}" ) val subscriptionData = SubscriptionData(subscriptionStatus = dbStateInfo.currentSubscription) stateMachine.updateData(subscriptionData) // Trigger appropriate events to transition to the correct state when (dbStateInfo.recommendedState) { SubscriptionState.Active -&gt; { val purchaseDetail = createPurchaseDetailFromSubscription(dbStateInfo.currentSubscription) stateMachine.processEvent(SubscriptionEvent.PaymentSuccessful(purchaseDetail)) } SubscriptionState.Cancelled -&gt; { // check if the billing expiry is in the past then handle as expired val isExpired = dbStateInfo.currentSubscription.billingExpiry &lt; System.currentTimeMillis() if (isExpired) { stateMachine.processEvent(SubscriptionEvent.UserCancelled) } else { stateMachine.processEvent(SubscriptionEvent.UserCancelled) } } SubscriptionState.Expired -&gt; { stateMachine.processEvent(SubscriptionEvent.SubscriptionExpired) } SubscriptionState.Revoked -&gt; { stateMachine.processEvent(SubscriptionEvent.SubscriptionRevoked) } SubscriptionState.Initial -&gt; { Logger.i( LOG_IAB, "$TAG: Database state matches current state - no transition needed" ) } SubscriptionState.PurchasePending -&gt; { val purchaseDetail = createPurchaseDetailFromSubscription(dbStateInfo.currentSubscription) stateMachine.processEvent(SubscriptionEvent.PurchaseCompleted(purchaseDetail)) } SubscriptionState.PurchaseInitiated -&gt; { stateMachine.processEvent(SubscriptionEvent.Initialize) } else -&gt; { Logger.w( LOG_IAB, "$TAG: Unexpected database state: ${dbStateInfo.recommendedState.name}" ) } } Logger.i(LOG_IAB, "$TAG: Database state restoration completed") } else { Logger.d(LOG_IAB, "$TAG: No database state to restore - system check completed") } } catch (e: Exception) { Logger.e( LOG_IAB, "$TAG: Error during system check and database restoration: ${e.message}", e ) } } private suspend fun handleSubscriptionExpired(data: SubscriptionData?) { try { Logger.w(LOG_IAB, "$TAG: Handling subscription expiry") data?.let { subscriptionData -&gt; subscriptionData.subscriptionStatus.status = SubscriptionStatus.SubscriptionState.STATE_EXPIRED.id val updateResult = subscriptionDb.upsert(subscriptionData.subscriptionStatus) if (updateResult &gt; 0) { // Update state machine data val updatedData = subscriptionData.copy(subscriptionStatus = subscriptionData.subscriptionStatus) stateMachine.updateData(updatedData) // Save state transition dbSyncService.saveStateTransition( fromState = stateMachine.getCurrentState(), toState = SubscriptionState.Expired, subscriptionData = updatedData, reason = "Subscription expired" ) // Update expiry information dbSyncService.updateSubscriptionExpiry( subscriptionData.subscriptionStatus.id, subscriptionData.subscriptionStatus.billingExpiry, subscriptionData.subscriptionStatus.accountExpiry ) // Deactivate RPN scope.launch { try { RpnProxyManager.deactivateRpn("expired") Logger.i(LOG_IAB, "$TAG: RPN deactivated due to expiry") } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error deactivating RPN: ${e.message}", e) } } Logger.w(LOG_IAB, "$TAG: Subscription expiry handled") } else { Logger.e(LOG_IAB, "$TAG: Failed to update subscription for expiry") } } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling subscription expiry: ${e.message}", e) } } private suspend fun handleSubscriptionRestored(purchaseDetail: PurchaseDetail) { try { Logger.i(LOG_IAB, "$TAG: Handling subscription restored: ${purchaseDetail.productId}") // Get existing subscription instead of creating new one val existingSubscription = getCurrentSubscriptionStatus(purchaseDetail) if (existingSubscription != null) { // Update existing subscription to active existingSubscription.status = SubscriptionStatus.SubscriptionState.STATE_ACTIVE.id val updateResult = subscriptionDb.upsert(existingSubscription) if (updateResult &gt; 0) { // Update state machine data val subscriptionData = SubscriptionData( subscriptionStatus = existingSubscription, purchaseDetail = purchaseDetail ) stateMachine.updateData(subscriptionData) // Save state transition (this will now properly update history) dbSyncService.saveStateTransition( fromState = SubscriptionState.Cancelled, toState = SubscriptionState.Active, subscriptionData = subscriptionData, reason = "Subscription restored" ) // Activate RPN if needed scope.launch { try { RpnProxyManager.activateRpn(purchaseDetail) Logger.i(LOG_IAB, "$TAG: RPN activated successfully") } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error activating RPN: ${e.message}", e) } } Logger.i(LOG_IAB, "$TAG: Subscription restored handled") } else { Logger.e(LOG_IAB, "$TAG: Failed to update subscription status") } } else { Logger.e(LOG_IAB, "$TAG: No existing subscription found for restoration") } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling subscription restoration: ${e.message}", e) } } private suspend fun handleSubscriptionRevoked(data: SubscriptionData?) { try { Logger.w(LOG_IAB, "$TAG: Handling subscription revocation") data?.let { subscriptionData -&gt; subscriptionData.subscriptionStatus.status = SubscriptionStatus.SubscriptionState.STATE_REVOKED.id val updateResult = subscriptionDb.upsert(subscriptionData.subscriptionStatus) if (updateResult &gt; 0) { // Update state machine data val updatedData = subscriptionData.copy(subscriptionStatus = subscriptionData.subscriptionStatus) stateMachine.updateData(updatedData) // Mark as revoked in database (this handles history) dbSyncService.markSubscriptionRevoked(updatedData.subscriptionStatus.id) // Save state transition dbSyncService.saveStateTransition( fromState = stateMachine.getCurrentState(), toState = SubscriptionState.Revoked, subscriptionData = updatedData, reason = "Subscription revoked by system" ) // Immediately deactivate RPN scope.launch { try { RpnProxyManager.deactivateRpn("revoked") Logger.w(LOG_IAB, "$TAG: RPN deactivated due to revocation") } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error deactivating RPN: ${e.message}", e) } } Logger.w(LOG_IAB, "$TAG: Subscription revocation handled") } else { Logger.e(LOG_IAB, "$TAG: Failed to update subscription for revocation") } } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling subscription revocation: ${e.message}", e) } } /** * Get current subscription status - prevents duplicate creation */ private suspend fun getCurrentSubscriptionStatus(purchaseDetail: PurchaseDetail): SubscriptionStatus? { return try { // First try by purchase token subscriptionDb.getByPurchaseToken(purchaseDetail.purchaseToken) ?: subscriptionDb.getCurrentSubscription() } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error getting current subscription: ${e.message}", e) null } } private suspend fun handleSystemCheck() { try { Logger.i(LOG_IAB, "$TAG: performing system check") // TODO: perform any necessary system checks here } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: err during system check: ${e.message}", e) } } private suspend fun handleErrorRecovery() { try { Logger.i(LOG_IAB, "$TAG: Handling error recovery") // Clear any error state and attempt to reload from database val dbStateInfo = dbSyncService.loadStateFromDatabase() if (dbStateInfo != null) { val subscriptionData = SubscriptionData(subscriptionStatus = dbStateInfo.currentSubscription) stateMachine.updateData(subscriptionData) Logger.i(LOG_IAB, "$TAG: Error recovery completed, restored state from database") } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error during error recovery: ${e.message}", e) } } private suspend fun handleBillingError(error: String, billingResult: BillingResult) { try { Logger.e(LOG_IAB, "$TAG: Handling billing error: $error") stateMachine.getCurrentData()?.let { data -&gt; dbSyncService.saveStateTransition( fromState = stateMachine.getCurrentState(), toState = SubscriptionState.Error, subscriptionData = data, reason = "Billing error: $error (${billingResult.responseCode})" ) } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling billing error: ${e.message}", e) } } private fun handleDatabaseError(error: String) { try { Logger.e(LOG_IAB, "$TAG: Handling database error: $error") // Don't try to save to database since that's what failed // Just log the error and potentially trigger recovery } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling database error: ${e.message}", e) } } private suspend fun handlePaymentInitiated(purchaseDetail: PurchaseDetail) { try { Logger.i( LOG_IAB, "$TAG: Handling payment initiated for purchase: ${purchaseDetail.productId}" ) // Update the existing subscription status to indicate payment processing has started val existingSubscription = getCurrentSubscriptionStatus(purchaseDetail) if (existingSubscription != null) { // Mark subscription as pending payment processing existingSubscription.status = SubscriptionStatus.SubscriptionState.STATE_INITIAL.id val updateResult = subscriptionDb.upsert(existingSubscription) if (updateResult &gt; 0) { // Update state machine data val subscriptionData = SubscriptionData( subscriptionStatus = existingSubscription, purchaseDetail = purchaseDetail ) stateMachine.updateData(subscriptionData) // Save state transition dbSyncService.saveStateTransition( fromState = SubscriptionState.Initial, toState = SubscriptionState.PurchaseInitiated, subscriptionData = subscriptionData, reason = "Payment processing initiated" ) Logger.i( LOG_IAB, "$TAG: Payment initiation handled - subscription marked as pending" ) } else { Logger.e(LOG_IAB, "$TAG: Failed to update subscription for payment initiation") } } else { Logger.e(LOG_IAB, "$TAG: No existing subscription found for payment initiation") } } catch (e: Exception) { Logger.e(LOG_IAB, "$TAG: Error handling payment initiation: ${e.message}", e) } } private fun io(f: suspend () -&gt; Unit) { CoroutineScope(Dispatchers.IO).launch { f() } } } */</ID>
    <ID>ForbiddenComment:VpnController.kt$VpnController$// FIXME: Publish VpnState through this live-data to relieve direct access</ID>
    <ID>ForbiddenComment:VpnController.kt$VpnController$// TODO: make clients listen on create, start, stop, destroy from vpn-service</ID>
    <ID>ForbiddenComment:WgConfigFilesDAO.kt$WgConfigFilesDAO$// TODO: should remove this query post v055o</ID>
    <ID>ForbiddenComment:WireguardManager.kt$WireguardManager$/* TODO: commenting the code as v055o doesn't use ip-app specific and domain-app specific // rules // check for ip-app specific config first // returns Pair&lt;String, String&gt; - first is ProxyId, second is CC val ipc = IpRulesManager.hasProxy(uid, ip, port) // return Pair&lt;String, Boolean&gt; - first is ProxyId, second is can proceed for next check // one case where second parameter is true when the config is in lockdown mode val ipcProxyPair = canUseConfig(ipc.first, "ip($ip:$port)", usesMeteredNw) if (!ipcProxyPair.second) { // false denotes first is not empty if (ipcProxyPair.first == block) { proxyIds.clear() proxyIds.add(block) } else { proxyIds.add(ipcProxyPair.first) } Logger.i(LOG_TAG_PROXY, "lockdown wg for ip($ip:$port) =&gt; return $proxyIds") return proxyIds } // add the ip-app specific config to the list if (ipc.first.isNotEmpty()) proxyIds.add(ipc.first) // ip-app specific // check for domain-app specific config val dc = DomainRulesManager.getProxyForDomain(uid, domain) val dcProxyPair = canUseConfig(dc.first, "domain($domain)", usesMeteredNw) if (!dcProxyPair.second) { if (ipcProxyPair.first == block) { proxyIds.clear() proxyIds.add(block) } else { proxyIds.add(ipcProxyPair.first) } Logger.i(LOG_TAG_PROXY, "lockdown wg for domain($domain) =&gt; return $proxyIds") return proxyIds } // add the domain-app specific config to the list if (dcProxyPair.first.isNotEmpty()) proxyIds.add(dcProxyPair.first) // domain-app specific */</ID>
    <ID>ForbiddenComment:WireguardManager.kt$WireguardManager$/* TODO: commenting the code as v055o doesn't use universal ip and domain rules // check for universal ip config val uipc = IpRulesManager.hasProxy(UID_EVERYBODY, ip, port) val uipcProxyPair = canUseConfig(uipc.first, "univ-ip($ip:$port)", usesMeteredNw) if (!uipcProxyPair.second) { if (ipcProxyPair.first == block) { proxyIds.clear() proxyIds.add(block) } else { proxyIds.add(ipcProxyPair.first) } Logger.i(LOG_TAG_PROXY, "lockdown wg for univ-ip($ip:$port) =&gt; return $proxyIds") return proxyIds // no need to proceed further for lockdown } // add the universal ip config to the list if (uipcProxyPair.first.isNotEmpty()) proxyIds.add(uipcProxyPair.first) // universal ip // check for universal domain config val udc = DomainRulesManager.getProxyForDomain(UID_EVERYBODY, domain) val udcProxyPair = canUseConfig(udc.first, "univ-dom($domain)", usesMeteredNw) if (!udcProxyPair.second) { if (ipcProxyPair.first == block) { proxyIds.clear() proxyIds.add(block) } else { proxyIds.add(ipcProxyPair.first) } Logger.i(LOG_TAG_PROXY, "lockdown wg for univ-dom($domain) =&gt; return $proxyIds") return proxyIds // no need to proceed further for lockdown } // add the universal domain config to the list if (udcProxyPair.first.isNotEmpty()) proxyIds.add(udcProxyPair.first)*/</ID>
    <ID>ForbiddenComment:WireguardManager.kt$WireguardManager$// TODO: delete the warp config from the wireguard directory, now part of rpn proxy</ID>
    <ID>FunctionNaming:AboutScreen.kt$@Composable fun AboutItem(title: String, iconId: Int, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:AboutScreen.kt$@Composable fun AboutScreen( uiState: AboutUiState, onSponsorClick: () -&gt; Unit, onTelegramClick: () -&gt; Unit, onBugReportClick: () -&gt; Unit, onWhatsNewClick: () -&gt; Unit, onAppUpdateClick: () -&gt; Unit, onContributorsClick: () -&gt; Unit, onTranslateClick: () -&gt; Unit, onWebsiteClick: () -&gt; Unit, onGithubClick: () -&gt; Unit, onFaqClick: () -&gt; Unit, onDocsClick: () -&gt; Unit, onPrivacyPolicyClick: () -&gt; Unit, onTermsOfServiceClick: () -&gt; Unit, onLicenseClick: () -&gt; Unit, onTwitterClick: () -&gt; Unit, onEmailClick: () -&gt; Unit, onRedditClick: () -&gt; Unit, onElementClick: () -&gt; Unit, onMastodonClick: () -&gt; Unit, onAppInfoClick: () -&gt; Unit, onVpnProfileClick: () -&gt; Unit, onNotificationClick: () -&gt; Unit, onStatsClick: () -&gt; Unit, onDbStatsClick: () -&gt; Unit, onFlightRecordClick: () -&gt; Unit, onEventLogsClick: () -&gt; Unit, onTokenClick: () -&gt; Unit, onTokenDoubleTap: () -&gt; Unit, onFossClick: () -&gt; Unit, onFlossFundsClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:AboutScreen.kt$@Composable fun AboutSection(title: String, content: @Composable ColumnScope.() -&gt; Unit)</ID>
    <ID>FunctionNaming:AboutScreen.kt$@Composable fun AboutSmallCard(title: String, iconId: Int, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:AdvancedSettingsScreen.kt$@Composable private fun SettingToggleRow( icon: ImageVector, title: String, description: String, checked: Boolean, onCheckedChange: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:AdvancedSettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AdvancedSettingsScreen( persistentState: PersistentState, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:AlertsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AlertsScreen(onBackClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:AntiCensorshipScreen.kt$@Composable private fun OptionRow( title: String, description: String, selected: Boolean, enabled: Boolean = true, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:AntiCensorshipScreen.kt$@Composable private fun SectionHeader(title: String, description: String)</ID>
    <ID>FunctionNaming:AntiCensorshipScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AntiCensorshipScreen( persistentState: PersistentState, eventLogger: EventLogger, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:AppDomainRulesDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AppDomainRulesSheet( uid: Int, domain: String, eventLogger: EventLogger, onDismiss: () -&gt; Unit, onUpdated: () -&gt; Unit )</ID>
    <ID>FunctionNaming:AppDomainRulesDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable private fun WireguardListSheet( inputLabel: String?, selectedProxyId: String, wgConfigs: List&lt;WgConfigFilesImmutable?&gt;, onDismiss: () -&gt; Unit, onSelected: (WgConfigFilesImmutable?) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppInfoScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AppInfoScreen( uid: Int, eventLogger: EventLogger, ipRulesViewModel: CustomIpViewModel, domainRulesViewModel: CustomDomainViewModel, networkLogsViewModel: AppConnectionsViewModel, onBackClick: () -&gt; Unit, onAppWiseIpLogsClick: (Int, Boolean) -&gt; Unit, onCustomRulesClick: (Int) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppIpRulesDialog.kt$@Composable private fun DomainRuleRow( domain: String, status: DomainRulesManager.Status, onUpdate: (DomainRulesManager.Status) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppIpRulesDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AppIpRulesSheet( uid: Int, ipAddress: String, domains: String, eventLogger: EventLogger, onDismiss: () -&gt; Unit, onUpdated: () -&gt; Unit )</ID>
    <ID>FunctionNaming:AppListScreen.kt$@Composable private fun AppListRecycler(viewModel: AppInfoViewModel, eventLogger: EventLogger)</ID>
    <ID>FunctionNaming:AppListScreen.kt$@Composable private fun BulkIconButton(icon: Int, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:AppListScreen.kt$@Composable private fun BulkToggleRow( bulkWifi: Boolean, bulkMobile: Boolean, bulkBypass: Boolean, bulkBypassDns: Boolean, bulkExclude: Boolean, bulkLockdown: Boolean, showBypassToolTip: Boolean, onShowInfoDialog: () -&gt; Unit, onShowBulkDialog: (BlockType) -&gt; Unit, onBypassDnsTooltip: () -&gt; Unit )</ID>
    <ID>FunctionNaming:AppListScreen.kt$@Composable private fun FirewallInfoDialogContent()</ID>
    <ID>FunctionNaming:AppListScreen.kt$@Composable private fun InfoRow(icon: Int, text: String)</ID>
    <ID>FunctionNaming:AppListScreen.kt$@Composable private fun TopFilterChip(label: String, selected: Boolean, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:AppListScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AppListScreen( viewModel: AppInfoViewModel, eventLogger: EventLogger, queryText: String, filterLabelText: CharSequence, selectedFirewallFilter: FirewallFilter, isRefreshing: Boolean, bulkWifi: Boolean, bulkMobile: Boolean, bulkBypass: Boolean, bulkBypassDns: Boolean, bulkExclude: Boolean, bulkLockdown: Boolean, showBulkUpdateDialog: Boolean, bulkDialogTitle: String, bulkDialogMessage: String, bulkDialogType: BlockType?, showInfoDialog: Boolean, currentFilters: Filters?, onQueryChange: (String) -&gt; Unit, onRefreshClick: () -&gt; Unit, onFilterApply: (Filters) -&gt; Unit, onFilterClear: (Filters) -&gt; Unit, onFirewallFilterClick: (FirewallFilter) -&gt; Unit, onBulkDialogConfirm: (BlockType) -&gt; Unit, onBulkDialogDismiss: () -&gt; Unit, onInfoDialogDismiss: () -&gt; Unit, onShowInfoDialog: () -&gt; Unit, onShowBulkDialog: (BlockType) -&gt; Unit, onBypassDnsTooltip: () -&gt; Unit, showBypassToolTip: Boolean, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:AppListScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun FirewallAppFilterSheet( initialFilters: Filters?, firewallFilter: FirewallFilter, onDismiss: () -&gt; Unit, onApply: (Filters) -&gt; Unit, onClear: (Filters) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppListScreen.kt$@OptIn(FlowPreview::class) @Composable fun AppListScreen( viewModel: AppInfoViewModel, eventLogger: EventLogger, refreshDatabase: RefreshDatabase, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:AppLockScreen.kt$@Composable fun AppLockScreen( persistentState: PersistentState, onAuthResult: (AppLockResult) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppLockScreen.kt$@Composable private fun AppLockContent(appName: String)</ID>
    <ID>FunctionNaming:AppWiseDomainLogsScreen.kt$@Composable fun AppWiseDomainLogsScreen( state: AppWiseDomainLogsState, items: LazyPagingItems&lt;AppConnection&gt;, eventLogger: EventLogger, onTimeCategoryChange: (AppConnectionsViewModel.TimeCategory) -&gt; Unit, onFilterChange: (String) -&gt; Unit, onDeleteLogs: () -&gt; Unit, defaultIcon: Drawable? )</ID>
    <ID>FunctionNaming:AppWiseDomainLogsScreen.kt$@Composable private fun AppWiseDomainList( items: LazyPagingItems&lt;AppConnection&gt;, uid: Int, eventLogger: EventLogger )</ID>
    <ID>FunctionNaming:AppWiseDomainLogsScreen.kt$@Composable private fun ToggleButton(label: String, selected: Boolean, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:AppWiseDomainLogsScreen.kt$@Composable private fun ToggleRow( selectedCategory: AppConnectionsViewModel.TimeCategory, onCategorySelected: (AppConnectionsViewModel.TimeCategory) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppWiseDomainLogsScreen.kt$@OptIn(FlowPreview::class) @Composable private fun HeaderRow( appIcon: Drawable?, searchHint: String, showDeleteIcon: Boolean, onDeleteClick: () -&gt; Unit, onQueryChange: (String) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppWiseDomainsAdapter.kt$@Composable fun CloseConnsDialog( conn: AppConnection, onConfirm: () -&gt; Unit, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:AppWiseDomainsAdapter.kt$@Composable fun DomainRow( conn: AppConnection, uid: Int, isActiveConn: Boolean, refreshToken: Int, onIpClick: (AppConnection) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppWiseDomainsAdapter.kt$@Composable private fun DomainProgress(conn: AppConnection, uid: Int, refresh: Int)</ID>
    <ID>FunctionNaming:AppWiseIpLogsScreen.kt$@Composable private fun AppWiseIpList( viewModel: AppConnectionsViewModel, uid: Int, isAsn: Boolean, isRethinkApp: Boolean, eventLogger: EventLogger )</ID>
    <ID>FunctionNaming:AppWiseIpLogsScreen.kt$@Composable private fun ToggleButton(label: String, selected: Boolean, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:AppWiseIpLogsScreen.kt$@Composable private fun ToggleRow( selectedCategory: AppConnectionsViewModel.TimeCategory, onCategoryChange: (AppConnectionsViewModel.TimeCategory) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppWiseIpLogsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun AppWiseIpLogsScreen( uid: Int, isAsn: Boolean, viewModel: AppConnectionsViewModel, eventLogger: EventLogger, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:AppWiseIpLogsScreen.kt$@OptIn(FlowPreview::class) @Composable private fun HeaderRow( viewModel: AppConnectionsViewModel, isAsn: Boolean, searchHint: String, appIcon: Drawable?, showDeleteIcon: Boolean, onDeleteClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:AppWiseIpsAdapter.kt$@Composable fun IpRow( conn: AppConnection, isAsn: Boolean, refreshToken: Int, onIpClick: (AppConnection) -&gt; Unit )</ID>
    <ID>FunctionNaming:AppWiseIpsAdapter.kt$@Composable private fun IpProgress(conn: AppConnection, refresh: Int)</ID>
    <ID>FunctionNaming:BackupRestoreDialog.kt$@Composable private fun ActionRow(icon: Int, title: String, description: String, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:BackupRestoreDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun BackupRestoreSheet( onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable fun AllowedAppRow(app: AllowedAppInfo, onRemove: () -&gt; Unit)</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable fun BlockedAppRow(app: BlockedAppInfo, onAllow: () -&gt; Unit)</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable fun BubbleScreen( vpnOn: Boolean, allowedItems: LazyPagingItems&lt;AllowedAppInfo&gt;, blockedItems: LazyPagingItems&lt;BlockedAppInfo&gt;, onAllowApp: (BlockedAppInfo, () -&gt; Unit) -&gt; Unit, onRemoveAllowed: (AllowedAppInfo, () -&gt; Unit) -&gt; Unit )</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable private fun AllowedHeader(count: Int)</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable private fun AppIcon(packageName: String)</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable private fun BlockedHeader()</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable private fun EmptyState()</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable private fun HeaderSection()</ID>
    <ID>FunctionNaming:BubbleScreen.kt$@Composable private fun LoadingCard()</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@Composable private fun PaymentAwaiting()</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@Composable private fun PaymentContent( selectedPlan: CheckoutPlan, onPlanSelected: (CheckoutPlan) -&gt; Unit, onStartPayment: () -&gt; Unit, onNavigateToProxy: () -&gt; Unit )</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@Composable private fun PaymentFailed(onNavigateToProxy: () -&gt; Unit)</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@Composable private fun PaymentSuccess(onNavigateToProxy: () -&gt; Unit)</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@Composable private fun PlanRow(plan: CheckoutPlan, isSelected: Boolean, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@Composable private fun PlanSelector( selectedPlan: CheckoutPlan, onPlanSelected: (CheckoutPlan) -&gt; Unit )</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@Composable private fun StatusScreen( title: String, message: String, buttonLabel: String, onButtonClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@Composable private fun TopBanner()</ID>
    <ID>FunctionNaming:CheckoutScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun CheckoutScreen( paymentStatus: TcpProxyHelper.PaymentStatus, onStartPayment: () -&gt; Unit, onNavigateToProxy: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun &lt;T : Any&gt; DnsEndpointListWithFab( paddingValues: PaddingValues, items: LazyPagingItems&lt;T&gt;, onFabClick: () -&gt; Unit, itemContent: @Composable (T) -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun CustomDohDialogContent( title: String, nameLabel: String, urlLabel: String, defaultName: String, initialUrl: String, checkboxLabel: String, loadNextIndex: suspend () -&gt; Int, nameForIndex: (Int) -&gt; String, onSubmit: (String, String, Boolean) -&gt; String?, invalidUrlMessage: String, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun CustomOdohDialogContent( title: String, nameLabel: String, proxyLabel: String, resolverLabel: String, defaultName: String, initialResolver: String, loadNextIndex: suspend () -&gt; Int, invalidUrlMessage: String, onSubmit: (String, String, String) -&gt; String?, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun DnsCryptDialogContent( appConfig: AppConfig, scope: CoroutineScope, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun DnsCryptListContent( paddingValues: PaddingValues, appConfig: AppConfig, dnsCryptViewModel: DnsCryptEndpointViewModel, dnsCryptRelayViewModel: DnsCryptRelayEndpointViewModel, scope: CoroutineScope )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun DnsProxyDialogContent( appNames: List&lt;String&gt;, nextIndex: Int, appConfig: AppConfig, persistentState: PersistentState, scope: CoroutineScope, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun DnsProxyListContent( paddingValues: PaddingValues, appConfig: AppConfig, persistentState: PersistentState, dnsProxyViewModel: DnsProxyEndpointViewModel, scope: CoroutineScope )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun DohListContent( paddingValues: PaddingValues, appConfig: AppConfig, dohViewModel: DoHEndpointViewModel, scope: CoroutineScope )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun DotListContent( paddingValues: PaddingValues, appConfig: AppConfig, dotViewModel: DoTEndpointViewModel, scope: CoroutineScope )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun FullWidthDialog( onDismiss: () -&gt; Unit, content: @Composable () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun OdohListContent( paddingValues: PaddingValues, appConfig: AppConfig, oDohViewModel: ODoHEndpointViewModel, scope: CoroutineScope )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@Composable private fun OtherDnsListContent( dnsType: DnsScreenType, paddingValues: PaddingValues, appConfig: AppConfig, persistentState: PersistentState, dohViewModel: DoHEndpointViewModel, dotViewModel: DoTEndpointViewModel, dnsProxyViewModel: DnsProxyEndpointViewModel, dnsCryptViewModel: DnsCryptEndpointViewModel, dnsCryptRelayViewModel: DnsCryptRelayEndpointViewModel, oDohViewModel: ODoHEndpointViewModel, scope: CoroutineScope )</ID>
    <ID>FunctionNaming:ConfigureOtherDnsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun ConfigureOtherDnsScreen( dnsType: DnsScreenType, appConfig: AppConfig, persistentState: PersistentState, dohViewModel: DoHEndpointViewModel, dotViewModel: DoTEndpointViewModel, dnsProxyViewModel: DnsProxyEndpointViewModel, dnsCryptViewModel: DnsCryptEndpointViewModel, dnsCryptRelayViewModel: DnsCryptRelayEndpointViewModel, oDohViewModel: ODoHEndpointViewModel, onBackClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureRethinkBasicScreen.kt$@Composable private fun RethinkBlocklistContent( modifier: Modifier = Modifier, context: Context, blocklistType: RethinkBlocklistManager.RethinkBlocklistType, filters: MutableLiveData&lt;RethinkBlocklistState.Filters&gt;, remoteFileTagViewModel: RethinkRemoteFileTagViewModel, localFileTagViewModel: RethinkLocalFileTagViewModel, remoteBlocklistPacksMapViewModel: RemoteBlocklistPacksMapViewModel, localBlocklistPacksMapViewModel: LocalBlocklistPacksMapViewModel, showDownload: Boolean, showConfigure: Boolean, isDownloading: Boolean, showRemoteProgress: Boolean, activeView: RethinkBlocklistState.BlocklistView, filterLabelText: String, showPlusFilterSheet: Boolean, plusFilterTags: List&lt;FileTag&gt;, onActiveViewChanged: (RethinkBlocklistState.BlocklistView) -&gt; Unit, onFilterLabelTextChanged: (String) -&gt; Unit, onShowPlusFilterSheetChanged: (Boolean) -&gt; Unit, onPlusFilterTagsChanged: (List&lt;FileTag&gt;) -&gt; Unit, onDownloadBlocklist: () -&gt; Unit, onCancelDownload: () -&gt; Unit, onApplyChanges: () -&gt; Unit, onRevertChanges: () -&gt; Unit, onRefreshBlocklistAvailability: () -&gt; Unit, onProcessSelectedFileTags: (String) -&gt; Unit, onModifiedStampChanged: (String) -&gt; Unit, getStampValue: () -&gt; String, onDownloadStart: () -&gt; Unit, onDownloadFail: () -&gt; Unit, onDownloadSuccess: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureRethinkBasicScreen.kt$@Composable private fun RethinkListContent( modifier: Modifier = Modifier, context: Context, persistentState: PersistentState, appConfig: AppConfig, appDownloadManager: AppDownloadManager, rethinkEndpointViewModel: RethinkEndpointViewModel, uid: Int, isMax: Boolean, updateAvailable: Boolean, checkUpdateVisible: Boolean, redownloadVisible: Boolean, checkUpdateInProgress: Boolean, updateInProgress: Boolean, onMaxChanged: (Boolean) -&gt; Unit, onUpdateMaxSwitchUi: () -&gt; Unit, onRefreshUpdateUi: () -&gt; Unit, onCheckUpdateInProgressChanged: (Boolean) -&gt; Unit, onUpdateInProgressChanged: (Boolean) -&gt; Unit, onCheckBlocklistUpdate: () -&gt; Unit, onDownload: (Long, Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureRethinkBasicScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun ConfigureRethinkBasicScreen( screenType: ConfigureRethinkScreenType, remoteName: String = "", remoteUrl: String = "", uid: Int = Constants.MISSING_UID, persistentState: PersistentState, appConfig: AppConfig, appDownloadManager: AppDownloadManager, rethinkEndpointViewModel: RethinkEndpointViewModel, remoteFileTagViewModel: RethinkRemoteFileTagViewModel, localFileTagViewModel: RethinkLocalFileTagViewModel, remoteBlocklistPacksMapViewModel: RemoteBlocklistPacksMapViewModel, localBlocklistPacksMapViewModel: LocalBlocklistPacksMapViewModel, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:ConfigureRethinkBasicScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable private fun RethinkPlusFilterSheet( context: Context, fileTags: List&lt;FileTag&gt;, filters: MutableLiveData&lt;RethinkBlocklistState.Filters&gt;, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureScreen.kt$@Composable fun ConfigureCard( title: String, iconId: Int, modifier: Modifier = Modifier, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConfigureScreen.kt$@Composable fun ConfigureScreen( isDebug: Boolean, onAppsClick: () -&gt; Unit, onDnsClick: () -&gt; Unit, onFirewallClick: () -&gt; Unit, onProxyClick: () -&gt; Unit, onNetworkClick: () -&gt; Unit, onOthersClick: () -&gt; Unit, onLogsClick: () -&gt; Unit, onAntiCensorshipClick: () -&gt; Unit, onAdvancedClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConnTrackerDialog.kt$@Composable private fun HtmlText(spanned: Spanned, modifier: Modifier = Modifier)</ID>
    <ID>FunctionNaming:ConnTrackerDialog.kt$@Composable private fun SelectionRow( label: @Composable () -&gt; Unit, labels: List&lt;String&gt;, selectedIndex: Int, onSelect: (Int) -&gt; Unit )</ID>
    <ID>FunctionNaming:ConnTrackerDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun ConnTrackerSheet( activity: FragmentActivity, info: ConnectionTracker, persistentState: PersistentState, eventLogger: EventLogger, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConnectionTrackerAdapter.kt$@Composable fun ConnectionRow( ct: ConnectionTracker, onShowConnTracker: (ConnectionTracker) -&gt; Unit )</ID>
    <ID>FunctionNaming:ConsoleLogAdapter.kt$@Composable fun ConsoleLogRow(log: ConsoleLog, isDebug: Boolean = DEBUG)</ID>
    <ID>FunctionNaming:ConsoleLogScreen.kt$@Composable private fun ConsoleLogList(viewModel: ConsoleLogViewModel)</ID>
    <ID>FunctionNaming:ConsoleLogScreen.kt$@Composable private fun SearchRow( query: String, onQueryChange: (String) -&gt; Unit, onFilterClick: () -&gt; Unit, onShareClick: () -&gt; Unit, onDeleteClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ConsoleLogScreen.kt$@OptIn(ExperimentalMaterial3Api::class, FlowPreview::class) @Composable fun ConsoleLogScreen( viewModel: ConsoleLogViewModel, consoleLogRepository: ConsoleLogRepository, persistentState: PersistentState, onShareClick: () -&gt; Unit, onDeleteComplete: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:CustomDomainRulesDialog.kt$@Composable private fun RuleChip( label: String, selected: Boolean, selectedText: Color, selectedContainer: Color, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:CustomDomainRulesDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun CustomDomainRulesSheet( customDomain: CustomDomain, eventLogger: EventLogger, onDismiss: () -&gt; Unit, onDeleted: () -&gt; Unit )</ID>
    <ID>FunctionNaming:CustomIpRulesDialog.kt$@Composable private fun RuleChip( label: String, selected: Boolean, selectedText: Color, selectedContainer: Color, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:CustomIpRulesDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun CustomIpRulesSheet( customIp: CustomIp, eventLogger: EventLogger, onDismiss: () -&gt; Unit, onDeleted: () -&gt; Unit )</ID>
    <ID>FunctionNaming:CustomLanIpDialog.kt$@Composable private fun IpRow( ipValue: String, prefixValue: String, ipHint: String, prefixHint: String, enabled: Boolean, onIpChange: (String) -&gt; Unit, onPrefixChange: (String) -&gt; Unit )</ID>
    <ID>FunctionNaming:CustomLanIpDialog.kt$@Composable private fun SectionTitle(text: String)</ID>
    <ID>FunctionNaming:CustomLanIpDialog.kt$@Composable private fun ToggleButton( text: String, selected: Boolean, selectedBg: Color, unselectedBg: Color, selectedText: Color, unselectedText: Color, modifier: Modifier, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:CustomLanIpDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun CustomLanIpSheet( persistentState: PersistentState, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:CustomRulesScreen.kt$@Composable private fun AddRuleDialog( isIpRule: Boolean, onDismiss: () -&gt; Unit, onAddIpRule: (String) -&gt; Unit, onAddDomainRule: (String) -&gt; Unit )</ID>
    <ID>FunctionNaming:CustomRulesScreen.kt$@Composable private fun DomainRuleRow(rule: CustomDomain, onDelete: () -&gt; Unit)</ID>
    <ID>FunctionNaming:CustomRulesScreen.kt$@Composable private fun IpRuleRow(rule: CustomIp, onDelete: () -&gt; Unit)</ID>
    <ID>FunctionNaming:CustomRulesScreen.kt$@OptIn(ExperimentalMaterial3Api::class, FlowPreview::class) @Composable fun CustomRulesScreen( domainViewModel: CustomDomainViewModel, ipViewModel: CustomIpViewModel, eventLogger: EventLogger, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:CustomRulesScreen.kt$@OptIn(FlowPreview::class) @Composable private fun DomainRulesContent(viewModel: CustomDomainViewModel, eventLogger: EventLogger)</ID>
    <ID>FunctionNaming:CustomRulesScreen.kt$@OptIn(FlowPreview::class) @Composable private fun IpRulesContent(viewModel: CustomIpViewModel, eventLogger: EventLogger)</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun AnimatedVisibilityFadeScale( visible: Boolean, modifier: Modifier = Modifier, content: @Composable () -&gt; Unit )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun AppCard( modifier: Modifier = Modifier, onClick: (() -&gt; Unit)? = null, colors: CardColors = CardDefaults.cardColors( containerColor = MaterialTheme.colorScheme.surfaceVariant ), content: @Composable ColumnScope.() -&gt; Unit )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun AppDivider( modifier: Modifier = Modifier, indent: Dp = Dimensions.spacingNone, color: Color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = Opacity.LOW) )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun AppListItem( modifier: Modifier = Modifier, icon: ImageVector? = null, iconPainter: Painter? = null, title: String, description: String? = null, trailing: @Composable (() -&gt; Unit)? = null, onClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun CompactEmptyState( modifier: Modifier = Modifier, message: String, icon: ImageVector? = null )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun EmptyStateView( modifier: Modifier = Modifier, illustration: Painter? = null, title: String? = null, message: String, actionLabel: String? = null, onAction: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun GroupedCard( modifier: Modifier = Modifier, title: String? = null, titleIcon: ImageVector? = null, content: @Composable ColumnScope.() -&gt; Unit )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun PrimaryButton( text: String, onClick: () -&gt; Unit, modifier: Modifier = Modifier, enabled: Boolean = true, icon: ImageVector? = null )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun SecondaryButton( text: String, onClick: () -&gt; Unit, modifier: Modifier = Modifier, enabled: Boolean = true, icon: ImageVector? = null )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun SectionHeader( title: String, modifier: Modifier = Modifier, actionLabel: String? = null, onAction: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:DesignComponents.kt$@Composable fun StatItem( label: String, value: String, modifier: Modifier = Modifier, isHighlighted: Boolean = false )</ID>
    <ID>FunctionNaming:DetailedStatisticsScreen.kt$@Composable fun DetailedStatisticsScreen( viewModel: DetailedStatisticsViewModel, type: SummaryStatisticsType, timeCategory: TimeCategory, onBackClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DetailedStatisticsScreen.kt$@Composable private fun DetailedStatItemCard(item: AppConnection, type: SummaryStatisticsType)</ID>
    <ID>FunctionNaming:DetailedStatisticsScreen.kt$@Composable private fun NoDataView(modifier: Modifier = Modifier)</ID>
    <ID>FunctionNaming:DetailedStatisticsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable private fun DetailedStatisticsTopBar(type: SummaryStatisticsType, onBackClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:DnsCryptEndpointAdapter.kt$@Composable fun DnsCryptRow(endpoint: DnsCryptEndpoint, appConfig: AppConfig)</ID>
    <ID>FunctionNaming:DnsCryptRelayEndpointAdapter.kt$@Composable fun RelayRow(endpoint: DnsCryptRelayEndpoint, appConfig: AppConfig)</ID>
    <ID>FunctionNaming:DnsCryptRelaysDialog.kt$@Composable fun DnsCryptRelaysDialog( appConfig: AppConfig, relays: LiveData&lt;PagingData&lt;DnsCryptRelayEndpoint&gt;&gt;, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsCryptRelaysDialog.kt$@Composable private fun DnsCryptRelaysContent( appConfig: AppConfig, relays: LiveData&lt;PagingData&lt;DnsCryptRelayEndpoint&gt;&gt;, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsDetailScreen.kt$@Composable fun DnsDetailScreen( viewModel: DnsSettingsViewModel, persistentState: PersistentState, appDownloadManager: AppDownloadManager, onCustomDnsClick: () -&gt; Unit, onRethinkPlusDnsClick: () -&gt; Unit, onLocalBlocklistConfigureClick: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:DnsDetailScreen.kt$@Composable private fun ActionButton( text: String, enabled: Boolean, modifier: Modifier = Modifier, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsDetailScreen.kt$@Composable private fun DownloadRow( label: String, isLoading: Boolean, enabled: Boolean, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsDetailScreen.kt$@Composable private fun RecordModeToggleRow( isAutoMode: Boolean, onAutoSelected: () -&gt; Unit, onManualSelected: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsDetailScreen.kt$@Composable private fun RecordTypeRow( type: ResourceRecordTypes, isAutoMode: Boolean, isSelected: Boolean, onToggle: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsDetailScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable private fun DnsRecordTypesSheet( persistentState: PersistentState, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsDetailScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable private fun LocalBlocklistsSheet( context: Context, headingText: String, enableLabel: String, enableColor: Color, versionText: String, canConfigure: Boolean, canCopy: Boolean, canSearch: Boolean, showCheckDownload: Boolean, showDownload: Boolean, showRedownload: Boolean, isChecking: Boolean, isDownloading: Boolean, isRedownloading: Boolean, persistentState: PersistentState, onDismiss: () -&gt; Unit, onEnableBlocklist: () -&gt; Unit, onConfigure: () -&gt; Unit, onCopy: () -&gt; Unit, onSearch: () -&gt; Unit, onCheckUpdate: () -&gt; Unit, onDownload: () -&gt; Unit, onRedownload: () -&gt; Unit, onDelete: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsListScreen.kt$@Composable private fun DnsCard( label: String, title: String, dots: List&lt;Int&gt;, type: AppConfig.DnsType, selectedType: AppConfig.DnsType?, selectedWorking: Boolean, modifier: Modifier = Modifier, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsListScreen.kt$@Composable private fun LegendItem(icon: Int, label: String)</ID>
    <ID>FunctionNaming:DnsListScreen.kt$@Composable private fun LegendRow()</ID>
    <ID>FunctionNaming:DnsListScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun DnsListScreen( appConfig: AppConfig, onConfigureOtherDns: (Int) -&gt; Unit, onConfigureRethinkBasic: (Int) -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:DnsLogAdapter.kt$@Composable fun DnsLogRow( log: DnsLog, loadFavIcon: Boolean, isRethinkDns: Boolean, onShowBlocklist: (DnsLog) -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsProxyEndpointAdapter.kt$@Composable fun DnsProxyEndpointRow(endpoint: DnsProxyEndpoint, appConfig: AppConfig)</ID>
    <ID>FunctionNaming:DnsSettingsScreen.kt$@Composable fun DnsHeader( title: String, isRefreshing: Boolean = false, onRefreshClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:DnsSettingsScreen.kt$@Composable fun DnsRadioButtonItem( title: String, selected: Boolean, onClick: () -&gt; Unit, onInfoClick: (() -&gt; Unit)? = null, showArrow: Boolean = false )</ID>
    <ID>FunctionNaming:DnsSettingsScreen.kt$@Composable fun DnsSettingsScreen( uiState: DnsSettingsUiState, onRefreshClick: () -&gt; Unit, onSystemDnsClick: () -&gt; Unit, onSystemDnsInfoClick: () -&gt; Unit, onCustomDnsClick: () -&gt; Unit, onRethinkPlusDnsClick: () -&gt; Unit, onSmartDnsClick: () -&gt; Unit, onSmartDnsInfoClick: () -&gt; Unit, onLocalBlocklistClick: () -&gt; Unit, onCustomDownloaderChange: (Boolean) -&gt; Unit, onPeriodicUpdateChange: (Boolean) -&gt; Unit, onDnsAlgChange: (Boolean) -&gt; Unit, onSplitDnsChange: (Boolean) -&gt; Unit, onBypassDnsBlockChange: (Boolean) -&gt; Unit, onAllowedRecordTypesClick: () -&gt; Unit, onFavIconChange: (Boolean) -&gt; Unit, onDnsCacheChange: (Boolean) -&gt; Unit, onProxyDnsChange: (Boolean) -&gt; Unit, onUndelegatedDomainsChange: (Boolean) -&gt; Unit, onFallbackChange: (Boolean) -&gt; Unit, onPreventLeaksChange: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:DnsSettingsScreen.kt$@Composable fun SettingsNavigationItem( title: String, description: String, iconId: Int, onClick: () -&gt; Unit, statusText: String? = null, statusColor: androidx.compose.ui.graphics.Color = MaterialTheme.colorScheme.onSurfaceVariant )</ID>
    <ID>FunctionNaming:DnsSettingsScreen.kt$@Composable fun SettingsSwitchItem( title: String, description: String, iconId: Int, checked: Boolean, onCheckedChange: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:DoTEndpointAdapter.kt$@Composable fun DoTEndpointRow(endpoint: DoTEndpoint, appConfig: AppConfig)</ID>
    <ID>FunctionNaming:DohEndpointAdapter.kt$@Composable fun DoHEndpointRow(endpoint: DoHEndpoint, appConfig: AppConfig)</ID>
    <ID>FunctionNaming:DomainConnectionsAdapter.kt$@Composable fun ConnectionRow(dc: AppConnection)</ID>
    <ID>FunctionNaming:DomainConnectionsScreen.kt$@Composable private fun ConnectionsList( viewModel: DomainConnectionsViewModel, type: DomainConnectionsInputType )</ID>
    <ID>FunctionNaming:DomainConnectionsScreen.kt$@Composable private fun EmptyState()</ID>
    <ID>FunctionNaming:DomainConnectionsScreen.kt$@Composable private fun Header(title: String, subtitle: String)</ID>
    <ID>FunctionNaming:DomainConnectionsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun DomainConnectionsScreen( viewModel: DomainConnectionsViewModel, type: DomainConnectionsInputType, flag: String, domain: String, asn: String, ip: String, isBlocked: Boolean, timeCategory: DomainConnectionsViewModel.TimeCategory, onBackClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:EventsAdapter.kt$@Composable fun EventCard(event: Event, onCopy: (String) -&gt; Unit)</ID>
    <ID>FunctionNaming:EventsScreen.kt$@Composable private fun EmptyState()</ID>
    <ID>FunctionNaming:EventsScreen.kt$@Composable private fun EventsList(items: androidx.paging.compose.LazyPagingItems&lt;Event&gt;, onCopy: (String) -&gt; Unit)</ID>
    <ID>FunctionNaming:EventsScreen.kt$@Composable private fun FilterChip(label: String, selected: Boolean, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:EventsScreen.kt$@Composable private fun SearchRow( query: String, onQueryChange: (String) -&gt; Unit, onFilterClick: () -&gt; Unit, onRefreshClick: () -&gt; Unit, onDeleteClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:EventsScreen.kt$@Composable private fun SeverityChips( filterType: TopLevelFilter, filterSeverity: Severity?, showSourceChips: Boolean, onAllClick: () -&gt; Unit, onSeverityClick: (Severity) -&gt; Unit, onSourceClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:EventsScreen.kt$@Composable private fun SourceChips( filterSources: Set&lt;EventSource&gt;, onToggle: (EventSource) -&gt; Unit )</ID>
    <ID>FunctionNaming:EventsScreen.kt$@OptIn(ExperimentalMaterial3Api::class, FlowPreview::class) @Composable fun EventsScreen( viewModel: EventsViewModel, eventDao: EventDao, onBackClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:FirewallAppListAdapter.kt$@Composable fun FirewallAppRow(appInfo: AppInfo, eventLogger: EventLogger)</ID>
    <ID>FunctionNaming:FirewallSettingsScreen.kt$@Composable fun FirewallSettingItem( title: String, description: String, iconId: Int, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:FirewallSettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun FirewallSettingsScreen( onUniversalFirewallClick: () -&gt; Unit, onCustomIpDomainClick: () -&gt; Unit, onAppWiseIpDomainClick: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:HomeComponents.kt$@Composable fun DashboardCard( title: String, iconId: Int, modifier: Modifier = Modifier, backgroundColor: Color = MaterialTheme.colorScheme.surfaceVariant, onClick: () -&gt; Unit, content: @Composable () -&gt; Unit )</ID>
    <ID>FunctionNaming:HomeComponents.kt$@Composable fun StartStopButton( isPlaying: Boolean, onClick: () -&gt; Unit, modifier: Modifier = Modifier )</ID>
    <ID>FunctionNaming:HomeComponents.kt$@Composable fun StatItem( label: String, value: String, modifier: Modifier = Modifier, isHighlighted: Boolean = false )</ID>
    <ID>FunctionNaming:HomeNavigation.kt$@Composable fun HomeScreenRoot( homeUiState: HomeScreenUiState, onHomeStartStopClick: () -&gt; Unit, onHomeDnsClick: () -&gt; Unit, onHomeFirewallClick: () -&gt; Unit, onHomeProxyClick: () -&gt; Unit, onHomeLogsClick: () -&gt; Unit, onHomeAppsClick: () -&gt; Unit, onHomeSponsorClick: () -&gt; Unit, summaryViewModel: SummaryStatisticsViewModel, onOpenDetailedStats: (SummaryStatisticsType) -&gt; Unit, startDestination: HomeRoute, isDebug: Boolean, onConfigureAppsClick: () -&gt; Unit, onConfigureDnsClick: () -&gt; Unit, onConfigureFirewallClick: () -&gt; Unit, onFirewallUniversalClick: () -&gt; Unit, onFirewallCustomIpClick: () -&gt; Unit, onFirewallAppWiseIpClick: () -&gt; Unit, onConfigureProxyClick: () -&gt; Unit, onConfigureNetworkClick: () -&gt; Unit, onConfigureOthersClick: () -&gt; Unit, onConfigureLogsClick: () -&gt; Unit, onConfigureAntiCensorshipClick: () -&gt; Unit, onConfigureAdvancedClick: () -&gt; Unit, aboutUiState: AboutUiState, onSponsorClick: () -&gt; Unit, onTelegramClick: () -&gt; Unit, onBugReportClick: () -&gt; Unit, onWhatsNewClick: () -&gt; Unit, onAppUpdateClick: () -&gt; Unit, onContributorsClick: () -&gt; Unit, onTranslateClick: () -&gt; Unit, onWebsiteClick: () -&gt; Unit, onGithubClick: () -&gt; Unit, onFaqClick: () -&gt; Unit, onDocsClick: () -&gt; Unit, onPrivacyPolicyClick: () -&gt; Unit, onTermsOfServiceClick: () -&gt; Unit, onLicenseClick: () -&gt; Unit, onTwitterClick: () -&gt; Unit, onEmailClick: () -&gt; Unit, onRedditClick: () -&gt; Unit, onElementClick: () -&gt; Unit, onMastodonClick: () -&gt; Unit, onAppInfoClick: () -&gt; Unit, onVpnProfileClick: () -&gt; Unit, onNotificationClick: () -&gt; Unit, onStatsClick: () -&gt; Unit, onDbStatsClick: () -&gt; Unit, onFlightRecordClick: () -&gt; Unit, onEventLogsClick: () -&gt; Unit, onTokenClick: () -&gt; Unit, onTokenDoubleTap: () -&gt; Unit, onFossClick: () -&gt; Unit, onFlossFundsClick: () -&gt; Unit, snackbarHostState: SnackbarHostState, detailedStatsViewModel: DetailedStatisticsViewModel, domainConnectionsViewModel: DomainConnectionsViewModel, eventsViewModel: EventsViewModel, eventDao: EventDao, appInfoEventLogger: EventLogger, appInfoIpRulesViewModel: CustomIpViewModel, appInfoDomainRulesViewModel: CustomDomainViewModel, appInfoNetworkLogsViewModel: AppConnectionsViewModel, persistentState: PersistentState, appConfig: AppConfig, onOpenVpnProfile: () -&gt; Unit, onRefreshDatabase: (() -&gt; Unit)? = null, consoleLogViewModel: ConsoleLogViewModel, consoleLogRepository: ConsoleLogRepository, onShareConsoleLogs: () -&gt; Unit, onConsoleLogsDeleteComplete: () -&gt; Unit, proxyAppsMappingViewModel: ProxyAppsMappingViewModel, dnsSettingsViewModel: DnsSettingsViewModel, appDownloadManager: AppDownloadManager, onDnsCustomDnsClick: () -&gt; Unit, onDnsRethinkPlusDnsClick: () -&gt; Unit, onDnsLocalBlocklistConfigureClick: () -&gt; Unit, homeNavRequest: HomeNavRequest?, onHomeNavConsumed: () -&gt; Unit, onAppLockResult: (AppLockResult) -&gt; Unit = {}, // ConfigureRethinkBasic dependencies rethinkEndpointViewModel: RethinkEndpointViewModel, remoteFileTagViewModel: RethinkRemoteFileTagViewModel, localFileTagViewModel: RethinkLocalFileTagViewModel, remoteBlocklistPacksMapViewModel: RemoteBlocklistPacksMapViewModel, localBlocklistPacksMapViewModel: LocalBlocklistPacksMapViewModel, appInfoViewModel: AppInfoViewModel, refreshDatabase: RefreshDatabase, connectionTrackerViewModel: ConnectionTrackerViewModel, dnsLogViewModel: DnsLogViewModel, rethinkLogViewModel: RethinkLogViewModel, connectionTrackerRepository: ConnectionTrackerRepository, dnsLogRepository: DnsLogRepository, rethinkLogRepository: RethinkLogRepository, onConfigureOtherDns: (Int) -&gt; Unit, // ConfigureOtherDns dependencies dohViewModel: DoHEndpointViewModel, dotViewModel: DoTEndpointViewModel, dnsProxyViewModel: DnsProxyEndpointViewModel, dnsCryptViewModel: DnsCryptEndpointViewModel, dnsCryptRelayViewModel: DnsCryptRelayEndpointViewModel, oDohViewModel: ODoHEndpointViewModel, // UniversalFirewallSettings callbacks onNavigateToLogs: (String) -&gt; Unit, onOpenAccessibilitySettings: () -&gt; Unit, // WireGuard dependencies wgConfigViewModel: WgConfigViewModel, // Checkout dependencies checkoutViewModel: CheckoutViewModel?, onNavigateToProxy: () -&gt; Unit, // WgMain callbacks onWgCreateClick: () -&gt; Unit, onWgImportClick: () -&gt; Unit, onWgQrScanClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:HomeScreen.kt$@Composable fun HomeScreen( uiState: HomeScreenUiState, onStartStopClick: () -&gt; Unit, onDnsClick: () -&gt; Unit, onFirewallClick: () -&gt; Unit, onProxyClick: () -&gt; Unit, onLogsClick: () -&gt; Unit, onAppsClick: () -&gt; Unit, onSponsorClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:HomeScreen.kt$@Preview @Composable fun HomeScreenPreview()</ID>
    <ID>FunctionNaming:HomeScreenActivity.kt$HomeScreenActivity$@Composable private fun BugReportFileRow( fileItem: BugReportFile, onShare: () -&gt; Unit, onDelete: () -&gt; Unit )</ID>
    <ID>FunctionNaming:HomeScreenActivity.kt$HomeScreenActivity$@Composable private fun ContributorsDialogContent(onDismiss: () -&gt; Unit)</ID>
    <ID>FunctionNaming:HomeScreenActivity.kt$HomeScreenActivity$@Composable private fun HomeDialogHost()</ID>
    <ID>FunctionNaming:HomeScreenActivity.kt$HomeScreenActivity$@Composable private fun HtmlText(text: String, textAlign: TextAlign)</ID>
    <ID>FunctionNaming:HomeScreenActivity.kt$HomeScreenActivity$@Composable private fun SponsorInfoDialogContent( amount: String, usageMessage: String, onSponsorClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:HomeScreenActivity.kt$HomeScreenActivity$@Composable private fun WhatsNewDialogContent()</ID>
    <ID>FunctionNaming:HomeScreenActivity.kt$HomeScreenActivity$@OptIn(ExperimentalMaterial3Api::class) @Composable private fun BugReportFilesSheet(onDismiss: () -&gt; Unit)</ID>
    <ID>FunctionNaming:LocalAdvancedViewAdapter.kt$@Composable fun LocalAdvancedBlocklistRow( filetag: RethinkLocalFileTag, showHeader: Boolean, onToggle: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:LocalSimpleViewAdapter.kt$@Composable fun LocalSimpleBlocklistRow( map: LocalBlocklistPacksMap, showHeader: Boolean, onToggle: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:MiscSettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun MiscSettingsScreen( persistentState: PersistentState, eventLogger: EventLogger, onBackClick: (() -&gt; Unit)? = null, onRefreshDatabase: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:NetworkLogsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable private fun ConnTrackerDetailsSheet( connection: ConnectionTracker, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:NetworkLogsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable private fun DnsLogDetailsSheet( log: DnsLog, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:NetworkLogsScreen.kt$@OptIn(ExperimentalMaterial3Api::class, FlowPreview::class) @Composable fun NetworkLogsScreen( connectionTrackerViewModel: ConnectionTrackerViewModel, dnsLogViewModel: DnsLogViewModel, rethinkLogViewModel: RethinkLogViewModel, connectionTrackerRepository: ConnectionTrackerRepository, dnsLogRepository: DnsLogRepository, rethinkLogRepository: RethinkLogRepository, persistentState: PersistentState, eventLogger: EventLogger, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:NetworkLogsScreen.kt$@OptIn(FlowPreview::class) @Composable private fun ConnectionLogsContent( viewModel: ConnectionTrackerViewModel, repository: ConnectionTrackerRepository, persistentState: PersistentState, onShowConnTracker: (ConnectionTracker) -&gt; Unit )</ID>
    <ID>FunctionNaming:NetworkLogsScreen.kt$@OptIn(FlowPreview::class) @Composable private fun DnsLogsContent( viewModel: DnsLogViewModel, repository: DnsLogRepository, persistentState: PersistentState, onShowDnsLog: (DnsLog) -&gt; Unit )</ID>
    <ID>FunctionNaming:NetworkReachabilityDialog.kt$@Composable private fun AddressRow( value: String, onValueChange: (String) -&gt; Unit, enabled: Boolean, progress: Boolean, result: ConnectionMonitor.ProbeResult? )</ID>
    <ID>FunctionNaming:NetworkReachabilityDialog.kt$@Composable private fun StatusIcon(isOk: Boolean)</ID>
    <ID>FunctionNaming:NetworkReachabilityDialog.kt$@Composable private fun ToggleButton(selected: Boolean, text: String, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:NetworkReachabilityDialog.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun NetworkReachabilitySheet( persistentState: PersistentState, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:ODoHEndpointAdapter.kt$@Composable fun ODoHEndpointRow(endpoint: ODoHEndpoint, appConfig: AppConfig)</ID>
    <ID>FunctionNaming:OneWgConfigAdapter.kt$@Composable fun OneWgConfigRow( config: WgConfigFiles, eventLogger: EventLogger, onDnsStatusChanged: () -&gt; Unit, onConfigDetailClick: (Int, WgType) -&gt; Unit )</ID>
    <ID>FunctionNaming:PauseScreen.kt$@Composable fun PauseScreen( onFinish: () -&gt; Unit )</ID>
    <ID>FunctionNaming:PauseScreen.kt$@Composable private fun ControlIcon( icon: Int, size: Dp, onClick: () -&gt; Unit, onLongClick: () -&gt; Unit, onRelease: () -&gt; Unit )</ID>
    <ID>FunctionNaming:PingTestScreen.kt$@Composable private fun PingField( value: String, readOnly: Boolean, status: PingStatus, onValueChange: (String) -&gt; Unit = {} )</ID>
    <ID>FunctionNaming:PingTestScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun PingTestScreen( onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:ProxySettingsScreen.kt$@Composable private fun ProxyCard( title: String, description: String, enabled: Boolean, onEnabledChange: (Boolean) -&gt; Unit, onConfigureClick: (() -&gt; Unit)? )</ID>
    <ID>FunctionNaming:ProxySettingsScreen.kt$@Composable private fun ProxyConfigDialog( title: String, onDismiss: () -&gt; Unit, onConfirm: (host: String, port: String, username: String, password: String) -&gt; Unit )</ID>
    <ID>FunctionNaming:ProxySettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun ProxySettingsScreen( appConfig: AppConfig, persistentState: PersistentState, eventLogger: EventLogger, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:RemoteAdvancedViewAdapter.kt$@Composable fun RemoteAdvancedBlocklistRow( filetag: RethinkRemoteFileTag, showHeader: Boolean, onToggle: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:RemoteSimpleViewAdapter.kt$@Composable fun RemoteSimpleBlocklistRow( map: RemoteBlocklistPacksMap, showHeader: Boolean, onToggle: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:RethinkEndpointAdapter.kt$@Composable fun RethinkEndpointRow( endpoint: RethinkDnsEndpoint, appConfig: AppConfig, onEditConfiguration: (ConfigureRethinkScreenType, String, String) -&gt; Unit = { _, _, _ -&gt; } )</ID>
    <ID>FunctionNaming:RethinkLogAdapter.kt$@Composable fun RethinkLogRow( log: RethinkLog, onShowConnTracker: (ConnectionTracker) -&gt; Unit )</ID>
    <ID>FunctionNaming:RpnAvailabilityScreen.kt$@Composable private fun AvailabilityRow(item: RpnAvailabilityItem)</ID>
    <ID>FunctionNaming:RpnAvailabilityScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun RpnAvailabilityScreen(onBackClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:RpnCountriesAdapter.kt$@Composable fun CountryRow(conf: String, isSelected: Boolean)</ID>
    <ID>FunctionNaming:RpnCountriesScreen.kt$@Composable private fun CountriesList(countries: List&lt;String&gt;, selectedCountries: Set&lt;String&gt;)</ID>
    <ID>FunctionNaming:RpnCountriesScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun RpnCountriesScreen(onBackClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:RpnWinProxyDetailsScreen.kt$@Composable private fun ActionButton(onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:RpnWinProxyDetailsScreen.kt$@Composable private fun DetailRow(label: String, value: String, valueColor: Color = MaterialTheme.colorScheme.onSurface)</ID>
    <ID>FunctionNaming:RpnWinProxyDetailsScreen.kt$@Composable private fun DetailsSection(countryCode: String, proxyError: String)</ID>
    <ID>FunctionNaming:RpnWinProxyDetailsScreen.kt$@Composable private fun StatCard(label: String, value: String, modifier: Modifier = Modifier)</ID>
    <ID>FunctionNaming:RpnWinProxyDetailsScreen.kt$@Composable private fun StatsRow(appsCount: String, domainsCount: String, ipsCount: String)</ID>
    <ID>FunctionNaming:RpnWinProxyDetailsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun RpnWinProxyDetailsScreen( countryCode: String, onBackClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:StatisticsSummaryItem.kt$@Composable fun StatisticsSummaryItem( title: String, subtitle: String?, countText: String, iconDrawable: Drawable?, flagText: String?, showProgress: Boolean, progress: Float, progressColor: Color, showIndicator: Boolean, onClick: (() -&gt; Unit)? )</ID>
    <ID>FunctionNaming:SubscriptionAnimDialog.kt$@Composable fun SubscriptionAnimDialog(onDismiss: () -&gt; Unit)</ID>
    <ID>FunctionNaming:SubscriptionAnimDialog.kt$@Composable private fun ConfettiOverlay()</ID>
    <ID>FunctionNaming:SummaryStatisticsScreen.kt$@Composable fun SummaryStatisticsScreen( viewModel: SummaryStatisticsViewModel, onSeeMoreClick: (SummaryStatisticsType) -&gt; Unit )</ID>
    <ID>FunctionNaming:SummaryStatisticsScreen.kt$@Composable private fun HeaderSection()</ID>
    <ID>FunctionNaming:SummaryStatisticsScreen.kt$@Composable private fun StatItemRow( item: AppConnection, type: SummaryStatisticsType )</ID>
    <ID>FunctionNaming:SummaryStatisticsScreen.kt$@Composable private fun StatSection( title: String, type: SummaryStatisticsType, pagingItems: LazyPagingItems&lt;AppConnection&gt;, onSeeMoreClick: (SummaryStatisticsType) -&gt; Unit )</ID>
    <ID>FunctionNaming:SummaryStatisticsScreen.kt$@Composable private fun TimeCategorySelector( selectedCategory: TimeCategory, onCategorySelected: (TimeCategory) -&gt; Unit )</ID>
    <ID>FunctionNaming:SummaryStatisticsScreen.kt$@Composable private fun UsageProgressHeader(dataUsage: DataUsageSummary)</ID>
    <ID>FunctionNaming:TcpProxyMainScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun TcpProxyMainScreen( appConfig: AppConfig, mappingViewModel: ProxyAppsMappingViewModel, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:Theme.kt$@Composable fun RethinkTheme( themeMode: RethinkThemeMode = if (isSystemInDarkTheme()) RethinkThemeMode.DARK else RethinkThemeMode.LIGHT, // Dynamic color is available on Android 12+ dynamicColor: Boolean = true, content: @Composable () -&gt; Unit )</ID>
    <ID>FunctionNaming:TunnelSettingsScreen.kt$@Composable private fun ConnectivityChecksDialog( persistentState: PersistentState, onDismiss: () -&gt; Unit, onConfirm: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:TunnelSettingsScreen.kt$@Composable private fun DefaultDnsDialog( persistentState: PersistentState, onDismiss: () -&gt; Unit, onConfirm: () -&gt; Unit )</ID>
    <ID>FunctionNaming:TunnelSettingsScreen.kt$@Composable private fun IpProtocolDialog( persistentState: PersistentState, context: Context, onDismiss: () -&gt; Unit, onConfirm: (Int) -&gt; Unit )</ID>
    <ID>FunctionNaming:TunnelSettingsScreen.kt$@Composable private fun SettingActionRow( icon: ImageVector, title: String, description: String, enabled: Boolean = true, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:TunnelSettingsScreen.kt$@Composable private fun SettingToggleRow( icon: ImageVector, title: String, description: String, checked: Boolean, enabled: Boolean, alpha: Float = 1f, onCheckedChange: (Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:TunnelSettingsScreen.kt$@Composable private fun VpnPolicyDialog( persistentState: PersistentState, context: Context, onDismiss: () -&gt; Unit, onConfirm: (Int) -&gt; Unit )</ID>
    <ID>FunctionNaming:TunnelSettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun TunnelSettingsScreen( persistentState: PersistentState, appConfig: AppConfig, eventLogger: EventLogger, onOpenVpnProfile: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:UniversalFirewallSettingsScreen.kt$@Composable private fun SectionHeader(title: String, description: String)</ID>
    <ID>FunctionNaming:UniversalFirewallSettingsScreen.kt$@Composable private fun StatsRow( stats: UniversalFirewallStatEntry?, loading: Boolean, onClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:UniversalFirewallSettingsScreen.kt$@Composable private fun ToggleWithStats( iconRes: Int, label: String, checked: Boolean, onCheckedChange: (Boolean) -&gt; Unit, stats: UniversalFirewallStatEntry?, loading: Boolean, onStatsClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:UniversalFirewallSettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun UniversalFirewallSettingsScreen( persistentState: PersistentState, eventLogger: EventLogger, connTrackerRepository: ConnectionTrackerRepository, onNavigateToLogs: (String) -&gt; Unit, onOpenAccessibilitySettings: () -&gt; Unit, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>FunctionNaming:Utilities.kt$Utilities$fun isAtleastO_MR1(): Boolean</ID>
    <ID>FunctionNaming:WelcomeScreen.kt$@Composable fun WelcomeScreen(onFinish: () -&gt; Unit)</ID>
    <ID>FunctionNaming:WelcomeScreen.kt$@Composable private fun DotsIndicator(count: Int, currentIndex: Int)</ID>
    <ID>FunctionNaming:WelcomeScreen.kt$@Composable private fun WelcomeSlideContent(slide: WelcomeSlide)</ID>
    <ID>FunctionNaming:WgAddPeerDialog.kt$@Composable fun WgAddPeerDialog( configId: Int, wgPeer: Peer?, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgConfigAdapter.kt$@Composable fun WgChip(text: String)</ID>
    <ID>FunctionNaming:WgConfigAdapter.kt$@Composable fun WgConfigRow( config: WgConfigFiles, eventLogger: EventLogger, onDnsStatusChanged: () -&gt; Unit, onConfigDetailClick: (Int, WgType) -&gt; Unit )</ID>
    <ID>FunctionNaming:WgConfigDetailScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun WgConfigDetailScreen( configId: Int, wgType: WgType, persistentState: PersistentState, eventLogger: EventLogger, mappingViewModel: ProxyAppsMappingViewModel, onEditConfig: (Int, WgType) -&gt; Unit, onBackClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgConfigEditorScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun WgConfigEditorScreen( configId: Int, wgType: WgType, persistentState: PersistentState, onBackClick: () -&gt; Unit, onSaveSuccess: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgHopAdapter.kt$@Composable fun HopRow( context: Context, srcId: Int, config: Config, isActive: Boolean, selectedId: Int, onSelectedIdChange: (Int) -&gt; Unit )</ID>
    <ID>FunctionNaming:WgHopAdapter.kt$@Composable private fun HopChip(text: String)</ID>
    <ID>FunctionNaming:WgHopDialog.kt$@Composable fun WgHopDialog( srcId: Int, hopables: List&lt;Config&gt;, selectedId: Int, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgIncludeAppsAdapter.kt$@Composable fun IncludeAppRow( mapping: ProxyApplicationMapping, proxyId: String, proxyName: String, onInterfaceUpdate: (ProxyApplicationMapping, Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:WgIncludeAppsAdapter.kt$@Composable fun IncludeDialogHost( state: IncludeDialogState?, onDismiss: () -&gt; Unit, onConfirm: (ProxyApplicationMapping, Boolean) -&gt; Unit )</ID>
    <ID>FunctionNaming:WgIncludeAppsDialog.kt$@Composable fun WgIncludeAppsDialog( viewModel: ProxyAppsMappingViewModel, proxyId: String, proxyName: String, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgIncludeAppsDialog.kt$@Composable private fun WgIncludeAppsDialogScreen( viewModel: ProxyAppsMappingViewModel, proxyId: String, proxyName: String, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgMainScreen.kt$@Composable private fun DisableConfigsDialog( onDismiss: () -&gt; Unit, onConfirm: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgMainScreen.kt$@Composable private fun EmptyState()</ID>
    <ID>FunctionNaming:WgMainScreen.kt$@Composable private fun FabStack( modifier: Modifier, isExpanded: Boolean, onMainClick: () -&gt; Unit, onCreateClick: () -&gt; Unit, onImportClick: () -&gt; Unit, onQrClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgMainScreen.kt$@Composable private fun ToggleButton(text: String, selected: Boolean, onClick: () -&gt; Unit)</ID>
    <ID>FunctionNaming:WgMainScreen.kt$@Composable private fun ToggleRow( selectedTab: WgTab, onOneWgClick: () -&gt; Unit, onGeneralClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgMainScreen.kt$@Composable private fun WgConfigContent( selectedTab: WgTab, disclaimerText: String, wgConfigViewModel: WgConfigViewModel, eventLogger: EventLogger, onDnsStatusChanged: () -&gt; Unit, onConfigDetailClick: (Int, WgType) -&gt; Unit, onOneWgToggleClick: () -&gt; Unit, onGeneralToggleClick: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgMainScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun WgMainScreen( wgConfigViewModel: WgConfigViewModel, persistentState: PersistentState, appConfig: AppConfig, eventLogger: EventLogger, onBackClick: () -&gt; Unit, onCreateClick: () -&gt; Unit, onImportClick: () -&gt; Unit, onQrScanClick: () -&gt; Unit, onConfigDetailClick: (Int, WgType) -&gt; Unit )</ID>
    <ID>FunctionNaming:WgPeersAdapter.kt$@Composable fun WgPeerRow( context: Context, configId: Int, wgPeer: Peer, onPeerChanged: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgPeersAdapter.kt$@Composable private fun LabelValue(label: String, value: String)</ID>
    <ID>FunctionNaming:WgSsidDialog.kt$@Composable fun WgSsidDialog( currentSsids: String, onSave: (String) -&gt; Unit, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgSsidDialog.kt$@Composable private fun SsidDialogContent( currentSsids: String, onSave: (String) -&gt; Unit, onDismiss: () -&gt; Unit )</ID>
    <ID>FunctionNaming:WgSsidDialog.kt$@Composable private fun SsidRow(ssidItem: SsidItem, onDeleteClick: () -&gt; Unit)</ID>
    <ID>FunctionParameterNaming:BraveVPNService.kt$BraveVPNService$_new: ConnectionMonitor.UnderlyingNetworks? = null</ID>
    <ID>ImplicitDefaultLocale:OkHttpDebugLogging.kt$OkHttpDebugLogging.&lt;no name provided&gt;$String.format("[%1\$tF %1\$tT] %2\$s %n", record.millis, record.message)</ID>
    <ID>ImplicitDefaultLocale:UIUtils.kt$UIUtils$String.format("%.1f %s", value, units[unitIndex])</ID>
    <ID>ImplicitDefaultLocale:Utilities.kt$Utilities$String.format("%s (%s)", countryCode, ipAddress)</ID>
    <ID>LongParameterList:AboutScreen.kt$( uiState: AboutUiState, onSponsorClick: () -&gt; Unit, onTelegramClick: () -&gt; Unit, onBugReportClick: () -&gt; Unit, onWhatsNewClick: () -&gt; Unit, onAppUpdateClick: () -&gt; Unit, onContributorsClick: () -&gt; Unit, onTranslateClick: () -&gt; Unit, onWebsiteClick: () -&gt; Unit, onGithubClick: () -&gt; Unit, onFaqClick: () -&gt; Unit, onDocsClick: () -&gt; Unit, onPrivacyPolicyClick: () -&gt; Unit, onTermsOfServiceClick: () -&gt; Unit, onLicenseClick: () -&gt; Unit, onTwitterClick: () -&gt; Unit, onEmailClick: () -&gt; Unit, onRedditClick: () -&gt; Unit, onElementClick: () -&gt; Unit, onMastodonClick: () -&gt; Unit, onAppInfoClick: () -&gt; Unit, onVpnProfileClick: () -&gt; Unit, onNotificationClick: () -&gt; Unit, onStatsClick: () -&gt; Unit, onDbStatsClick: () -&gt; Unit, onFlightRecordClick: () -&gt; Unit, onEventLogsClick: () -&gt; Unit, onTokenClick: () -&gt; Unit, onTokenDoubleTap: () -&gt; Unit, onFossClick: () -&gt; Unit, onFlossFundsClick: () -&gt; Unit )</ID>
    <ID>LongParameterList:AppListScreen.kt$( viewModel: AppInfoViewModel, eventLogger: EventLogger, queryText: String, filterLabelText: CharSequence, selectedFirewallFilter: FirewallFilter, isRefreshing: Boolean, bulkWifi: Boolean, bulkMobile: Boolean, bulkBypass: Boolean, bulkBypassDns: Boolean, bulkExclude: Boolean, bulkLockdown: Boolean, showBulkUpdateDialog: Boolean, bulkDialogTitle: String, bulkDialogMessage: String, bulkDialogType: BlockType?, showInfoDialog: Boolean, currentFilters: Filters?, onQueryChange: (String) -&gt; Unit, onRefreshClick: () -&gt; Unit, onFilterApply: (Filters) -&gt; Unit, onFilterClear: (Filters) -&gt; Unit, onFirewallFilterClick: (FirewallFilter) -&gt; Unit, onBulkDialogConfirm: (BlockType) -&gt; Unit, onBulkDialogDismiss: () -&gt; Unit, onInfoDialogDismiss: () -&gt; Unit, onShowInfoDialog: () -&gt; Unit, onShowBulkDialog: (BlockType) -&gt; Unit, onBypassDnsTooltip: () -&gt; Unit, showBypassToolTip: Boolean, onBackClick: (() -&gt; Unit)? = null )</ID>
    <ID>LongParameterList:ConfigureRethinkBasicScreen.kt$( modifier: Modifier = Modifier, context: Context, blocklistType: RethinkBlocklistManager.RethinkBlocklistType, filters: MutableLiveData&lt;RethinkBlocklistState.Filters&gt;, remoteFileTagViewModel: RethinkRemoteFileTagViewModel, localFileTagViewModel: RethinkLocalFileTagViewModel, remoteBlocklistPacksMapViewModel: RemoteBlocklistPacksMapViewModel, localBlocklistPacksMapViewModel: LocalBlocklistPacksMapViewModel, showDownload: Boolean, showConfigure: Boolean, isDownloading: Boolean, showRemoteProgress: Boolean, activeView: RethinkBlocklistState.BlocklistView, filterLabelText: String, showPlusFilterSheet: Boolean, plusFilterTags: List&lt;FileTag&gt;, onActiveViewChanged: (RethinkBlocklistState.BlocklistView) -&gt; Unit, onFilterLabelTextChanged: (String) -&gt; Unit, onShowPlusFilterSheetChanged: (Boolean) -&gt; Unit, onPlusFilterTagsChanged: (List&lt;FileTag&gt;) -&gt; Unit, onDownloadBlocklist: () -&gt; Unit, onCancelDownload: () -&gt; Unit, onApplyChanges: () -&gt; Unit, onRevertChanges: () -&gt; Unit, onRefreshBlocklistAvailability: () -&gt; Unit, onProcessSelectedFileTags: (String) -&gt; Unit, onModifiedStampChanged: (String) -&gt; Unit, getStampValue: () -&gt; String, onDownloadStart: () -&gt; Unit, onDownloadFail: () -&gt; Unit, onDownloadSuccess: () -&gt; Unit )</ID>
    <ID>LongParameterList:ConfigureRethinkBasicScreen.kt$( modifier: Modifier = Modifier, context: Context, persistentState: PersistentState, appConfig: AppConfig, appDownloadManager: AppDownloadManager, rethinkEndpointViewModel: RethinkEndpointViewModel, uid: Int, isMax: Boolean, updateAvailable: Boolean, checkUpdateVisible: Boolean, redownloadVisible: Boolean, checkUpdateInProgress: Boolean, updateInProgress: Boolean, onMaxChanged: (Boolean) -&gt; Unit, onUpdateMaxSwitchUi: () -&gt; Unit, onRefreshUpdateUi: () -&gt; Unit, onCheckUpdateInProgressChanged: (Boolean) -&gt; Unit, onUpdateInProgressChanged: (Boolean) -&gt; Unit, onCheckBlocklistUpdate: () -&gt; Unit, onDownload: (Long, Boolean) -&gt; Unit )</ID>
    <ID>LongParameterList:DnsDetailScreen.kt$( context: Context, headingText: String, enableLabel: String, enableColor: Color, versionText: String, canConfigure: Boolean, canCopy: Boolean, canSearch: Boolean, showCheckDownload: Boolean, showDownload: Boolean, showRedownload: Boolean, isChecking: Boolean, isDownloading: Boolean, isRedownloading: Boolean, persistentState: PersistentState, onDismiss: () -&gt; Unit, onEnableBlocklist: () -&gt; Unit, onConfigure: () -&gt; Unit, onCopy: () -&gt; Unit, onSearch: () -&gt; Unit, onCheckUpdate: () -&gt; Unit, onDownload: () -&gt; Unit, onRedownload: () -&gt; Unit, onDelete: () -&gt; Unit )</ID>
    <ID>LongParameterList:DnsSettingsScreen.kt$( uiState: DnsSettingsUiState, onRefreshClick: () -&gt; Unit, onSystemDnsClick: () -&gt; Unit, onSystemDnsInfoClick: () -&gt; Unit, onCustomDnsClick: () -&gt; Unit, onRethinkPlusDnsClick: () -&gt; Unit, onSmartDnsClick: () -&gt; Unit, onSmartDnsInfoClick: () -&gt; Unit, onLocalBlocklistClick: () -&gt; Unit, onCustomDownloaderChange: (Boolean) -&gt; Unit, onPeriodicUpdateChange: (Boolean) -&gt; Unit, onDnsAlgChange: (Boolean) -&gt; Unit, onSplitDnsChange: (Boolean) -&gt; Unit, onBypassDnsBlockChange: (Boolean) -&gt; Unit, onAllowedRecordTypesClick: () -&gt; Unit, onFavIconChange: (Boolean) -&gt; Unit, onDnsCacheChange: (Boolean) -&gt; Unit, onProxyDnsChange: (Boolean) -&gt; Unit, onUndelegatedDomainsChange: (Boolean) -&gt; Unit, onFallbackChange: (Boolean) -&gt; Unit, onPreventLeaksChange: (Boolean) -&gt; Unit )</ID>
    <ID>LongParameterList:HomeNavigation.kt$( homeUiState: HomeScreenUiState, onHomeStartStopClick: () -&gt; Unit, onHomeDnsClick: () -&gt; Unit, onHomeFirewallClick: () -&gt; Unit, onHomeProxyClick: () -&gt; Unit, onHomeLogsClick: () -&gt; Unit, onHomeAppsClick: () -&gt; Unit, onHomeSponsorClick: () -&gt; Unit, summaryViewModel: SummaryStatisticsViewModel, onOpenDetailedStats: (SummaryStatisticsType) -&gt; Unit, startDestination: HomeRoute, isDebug: Boolean, onConfigureAppsClick: () -&gt; Unit, onConfigureDnsClick: () -&gt; Unit, onConfigureFirewallClick: () -&gt; Unit, onFirewallUniversalClick: () -&gt; Unit, onFirewallCustomIpClick: () -&gt; Unit, onFirewallAppWiseIpClick: () -&gt; Unit, onConfigureProxyClick: () -&gt; Unit, onConfigureNetworkClick: () -&gt; Unit, onConfigureOthersClick: () -&gt; Unit, onConfigureLogsClick: () -&gt; Unit, onConfigureAntiCensorshipClick: () -&gt; Unit, onConfigureAdvancedClick: () -&gt; Unit, aboutUiState: AboutUiState, onSponsorClick: () -&gt; Unit, onTelegramClick: () -&gt; Unit, onBugReportClick: () -&gt; Unit, onWhatsNewClick: () -&gt; Unit, onAppUpdateClick: () -&gt; Unit, onContributorsClick: () -&gt; Unit, onTranslateClick: () -&gt; Unit, onWebsiteClick: () -&gt; Unit, onGithubClick: () -&gt; Unit, onFaqClick: () -&gt; Unit, onDocsClick: () -&gt; Unit, onPrivacyPolicyClick: () -&gt; Unit, onTermsOfServiceClick: () -&gt; Unit, onLicenseClick: () -&gt; Unit, onTwitterClick: () -&gt; Unit, onEmailClick: () -&gt; Unit, onRedditClick: () -&gt; Unit, onElementClick: () -&gt; Unit, onMastodonClick: () -&gt; Unit, onAppInfoClick: () -&gt; Unit, onVpnProfileClick: () -&gt; Unit, onNotificationClick: () -&gt; Unit, onStatsClick: () -&gt; Unit, onDbStatsClick: () -&gt; Unit, onFlightRecordClick: () -&gt; Unit, onEventLogsClick: () -&gt; Unit, onTokenClick: () -&gt; Unit, onTokenDoubleTap: () -&gt; Unit, onFossClick: () -&gt; Unit, onFlossFundsClick: () -&gt; Unit, snackbarHostState: SnackbarHostState, detailedStatsViewModel: DetailedStatisticsViewModel, domainConnectionsViewModel: DomainConnectionsViewModel, eventsViewModel: EventsViewModel, eventDao: EventDao, appInfoEventLogger: EventLogger, appInfoIpRulesViewModel: CustomIpViewModel, appInfoDomainRulesViewModel: CustomDomainViewModel, appInfoNetworkLogsViewModel: AppConnectionsViewModel, persistentState: PersistentState, appConfig: AppConfig, onOpenVpnProfile: () -&gt; Unit, onRefreshDatabase: (() -&gt; Unit)? = null, consoleLogViewModel: ConsoleLogViewModel, consoleLogRepository: ConsoleLogRepository, onShareConsoleLogs: () -&gt; Unit, onConsoleLogsDeleteComplete: () -&gt; Unit, proxyAppsMappingViewModel: ProxyAppsMappingViewModel, dnsSettingsViewModel: DnsSettingsViewModel, appDownloadManager: AppDownloadManager, onDnsCustomDnsClick: () -&gt; Unit, onDnsRethinkPlusDnsClick: () -&gt; Unit, onDnsLocalBlocklistConfigureClick: () -&gt; Unit, homeNavRequest: HomeNavRequest?, onHomeNavConsumed: () -&gt; Unit, onAppLockResult: (AppLockResult) -&gt; Unit = {}, // ConfigureRethinkBasic dependencies rethinkEndpointViewModel: RethinkEndpointViewModel, remoteFileTagViewModel: RethinkRemoteFileTagViewModel, localFileTagViewModel: RethinkLocalFileTagViewModel, remoteBlocklistPacksMapViewModel: RemoteBlocklistPacksMapViewModel, localBlocklistPacksMapViewModel: LocalBlocklistPacksMapViewModel, appInfoViewModel: AppInfoViewModel, refreshDatabase: RefreshDatabase, connectionTrackerViewModel: ConnectionTrackerViewModel, dnsLogViewModel: DnsLogViewModel, rethinkLogViewModel: RethinkLogViewModel, connectionTrackerRepository: ConnectionTrackerRepository, dnsLogRepository: DnsLogRepository, rethinkLogRepository: RethinkLogRepository, onConfigureOtherDns: (Int) -&gt; Unit, // ConfigureOtherDns dependencies dohViewModel: DoHEndpointViewModel, dotViewModel: DoTEndpointViewModel, dnsProxyViewModel: DnsProxyEndpointViewModel, dnsCryptViewModel: DnsCryptEndpointViewModel, dnsCryptRelayViewModel: DnsCryptRelayEndpointViewModel, oDohViewModel: ODoHEndpointViewModel, // UniversalFirewallSettings callbacks onNavigateToLogs: (String) -&gt; Unit, onOpenAccessibilitySettings: () -&gt; Unit, // WireGuard dependencies wgConfigViewModel: WgConfigViewModel, // Checkout dependencies checkoutViewModel: CheckoutViewModel?, onNavigateToProxy: () -&gt; Unit, // WgMain callbacks onWgCreateClick: () -&gt; Unit, onWgImportClick: () -&gt; Unit, onWgQrScanClick: () -&gt; Unit )</ID>
    <ID>LoopWithTooManyJumpStatements:ErrorMessages.kt$ErrorMessages$while</ID>
    <ID>LoopWithTooManyJumpStatements:IpRulesManager.kt$IpRulesManager$for</ID>
    <ID>LoopWithTooManyJumpStatements:NetLogBatcher.kt$NetLogBatcher$for</ID>
    <ID>LoopWithTooManyJumpStatements:TunnelImporter.kt$TunnelImporter$while</ID>
    <ID>MatchingDeclarationName:AppWiseDomainLogsScreen.kt$AppWiseDomainLogsState</ID>
    <ID>MatchingDeclarationName:CheckoutScreen.kt$CheckoutPlan</ID>
    <ID>MatchingDeclarationName:ConfigureOtherDnsScreen.kt$DnsScreenType</ID>
    <ID>MatchingDeclarationName:ConfigureRethinkBasicScreen.kt$ConfigureRethinkScreenType</ID>
    <ID>MatchingDeclarationName:HomeScreen.kt$HomeScreenUiState</ID>
    <ID>MatchingDeclarationName:NotificationActions.kt$NotificationActionType</ID>
    <ID>MatchingDeclarationName:UniversalFirewallSettingsScreen.kt$UniversalFirewallStatEntry</ID>
    <ID>MatchingDeclarationName:VPNControlReceiver.kt$VpnControlReceiver : BroadcastReceiverKoinComponent</ID>
    <ID>MatchingDeclarationName:WgIncludeAppsAdapter.kt$IncludeDialogState</ID>
    <ID>MemberNameEqualsClassName:DataModule.kt$DataModule$private val dataModule = module { single { AppConfig( androidContext(), get(), get(), get(), get(), get(), get(), get(), get(), get(), get(), get(), get() ) } }</ID>
    <ID>MemberNameEqualsClassName:DatabaseModule.kt$DatabaseModule$private val databaseModule = module { single { AppDatabase.buildDatabase(androidContext()) } single { LogDatabase.buildDatabase(androidContext()) } single { ConsoleLogDatabase.buildDatabase(androidContext()) } }</ID>
    <ID>MemberNameEqualsClassName:ViewModelModule.kt$ViewModelModule$private val viewModelModule = module { viewModel { HomeScreenViewModel(get(), get()) } viewModel { DnsSettingsViewModel(get(), get()) } viewModel { AboutViewModel(get(), get(), get()) } viewModel { ConnectionTrackerViewModel(get()) } viewModel { DnsCryptEndpointViewModel(get()) } viewModel { DnsCryptRelayEndpointViewModel(get()) } viewModel { DnsLogViewModel(get()) } viewModel { DnsProxyEndpointViewModel(get()) } viewModel { DoHEndpointViewModel(get()) } viewModel { AppInfoViewModel(get()) } viewModel { CustomDomainViewModel(get()) } viewModel { CustomIpViewModel(get()) } viewModel { RethinkEndpointViewModel(get()) } viewModel { AppCustomIpViewModel(get()) } viewModel { RethinkRemoteFileTagViewModel(get()) } viewModel { RethinkLocalFileTagViewModel(get()) } viewModel { AppConnectionsViewModel(get(), get(), get()) } viewModel { SummaryStatisticsViewModel(get(), get()) } viewModel { DetailedStatisticsViewModel(get(), get()) } viewModel { LocalBlocklistPacksMapViewModel(get()) } viewModel { RemoteBlocklistPacksMapViewModel(get()) } viewModel { ProxyAppsMappingViewModel(get()) } viewModel { WgConfigViewModel(get()) } viewModel { CheckoutViewModel(androidApplication(), get()) } viewModel { DoTEndpointViewModel(get()) } viewModel { ODoHEndpointViewModel(get()) } viewModel { RethinkLogViewModel(get()) } viewModel { AlertsViewModel(get(), get()) } viewModel { ConsoleLogViewModel(get()) } viewModel { DomainConnectionsViewModel(get()) } viewModel { WgNwActivityViewModel(get()) } viewModel { EventsViewModel(get()) } }</ID>
    <ID>NestedBlockDepth:AppDownloadManager.kt$AppDownloadManager$private fun cancelAndroidDownloadManagerDownloads()</ID>
    <ID>NestedBlockDepth:BackupAgent.kt$BackupAgent$private fun backupWireGuardConfig(tempDir: File): Boolean</ID>
    <ID>NestedBlockDepth:BraveVPNService.kt$BraveVPNService$private fun addRoute4(b: Builder): Builder</ID>
    <ID>NestedBlockDepth:BraveVPNService.kt$BraveVPNService$private fun route4(nws: Networks): Boolean</ID>
    <ID>NestedBlockDepth:BraveVPNService.kt$BraveVPNService$private fun route6(nws: Networks): Boolean</ID>
    <ID>NestedBlockDepth:BubbleHelper.kt$BubbleHelper$@RequiresApi(Build.VERSION_CODES.Q) fun updateBubble( context: Context, blockedCount: Int, persistentState: PersistentState? = null )</ID>
    <ID>NestedBlockDepth:BugReportZipper.kt$BugReportZipper$@RequiresApi(Build.VERSION_CODES.O) fun rezipAll(dir: File, file: File)</ID>
    <ID>NestedBlockDepth:BugReportZipper.kt$BugReportZipper$@RequiresApi(Build.VERSION_CODES.R) fun dumpAppExit(aei: ApplicationExitInfo, file: File)</ID>
    <ID>NestedBlockDepth:ConnTrackerDialog.kt$private fun updateBlockedRulesChip( activity: FragmentActivity, info: ConnectionTracker, persistentState: PersistentState, onText: (String) -&gt; Unit, onIcon: (Int) -&gt; Unit, onNegative: (Boolean) -&gt; Unit )</ID>
    <ID>NestedBlockDepth:ConnectionMonitor.kt$ConnectionMonitor$fun getNetworkSSID(network: Network?, cap: NetworkCapabilities?): String?</ID>
    <ID>NestedBlockDepth:ConnectionMonitor.kt$ConnectionMonitor.NetworkRequestHandler$private suspend fun repopulateTrackedNetworks( opPrefs: OpPrefs, nwProps: LinkedHashSet&lt;NetworkProperties&gt; )</ID>
    <ID>NestedBlockDepth:DnsLogTracker.kt$DnsLogTracker$suspend fun makeDnsLogObj(transaction: Transaction): DnsLog</ID>
    <ID>NestedBlockDepth:DownloadWatcher.kt$DownloadWatcher$private fun checkForDownload(context: Context, downloadIds: MutableList&lt;Long&gt;?): Int</ID>
    <ID>NestedBlockDepth:EnhancedBugReport.kt$EnhancedBugReport$@RequiresApi(Build.VERSION_CODES.O) fun addLogsToZipFile(context: Context)</ID>
    <ID>NestedBlockDepth:EnhancedBugReport.kt$EnhancedBugReport$private fun performRotation(context: Context)</ID>
    <ID>NestedBlockDepth:HomeScreenActivity.kt$HomeScreenActivity$private fun collectAllBugReportFiles(): List&lt;BugReportFile&gt;</ID>
    <ID>NestedBlockDepth:HomeScreenActivity.kt$HomeScreenActivity$private fun createCombinedZip(files: List&lt;File&gt;): Uri?</ID>
    <ID>NestedBlockDepth:HomeScreenViewModel.kt$HomeScreenViewModel$private suspend fun updateUiWithProxyStates()</ID>
    <ID>NestedBlockDepth:IpInfoDownloader.kt$IpInfoDownloader$private suspend fun performIpInfoDownload(ipToLookup: String): Boolean</ID>
    <ID>NestedBlockDepth:IpRulesManager.kt$IpRulesManager$suspend fun load(): Long</ID>
    <ID>NestedBlockDepth:LogExportWorker.kt$LogExportWorker$private fun exportLogsToCsvStream(filePath: String): Boolean</ID>
    <ID>NestedBlockDepth:NetworkBindingService.kt$NetworkBindingService$private suspend fun bindAny( who: String, addrPort: String, fid: Long, networks: List&lt;NetworkProperties&gt; ): Boolean</ID>
    <ID>NestedBlockDepth:RestoreAgent.kt$RestoreAgent$private fun isMetadataCompatible(tempDirectory: String?): Boolean</ID>
    <ID>NestedBlockDepth:StateMachineFramework.kt$StateMachine$suspend fun processEvent(event: E, newData: D? = null)</ID>
    <ID>NestedBlockDepth:Utilities.kt$Utilities$fun copyWithStream(readStream: InputStream, writeStream: OutputStream): Boolean</ID>
    <ID>NestedBlockDepth:WgInterface.kt$WgInterface.Builder$@Throws(BadConfigException::class) fun parseDnsServers(dnsServers: CharSequence?): Builder</ID>
    <ID>NewLineAtEndOfFile:RpnProxy.kt$com.celzero.bravedns.database.RpnProxy.kt</ID>
    <ID>NewLineAtEndOfFile:RpnProxyManager.kt$com.celzero.bravedns.rpnproxy.RpnProxyManager.kt</ID>
    <ID>NewLineAtEndOfFile:SubscriptionStatusRepository.kt$com.celzero.bravedns.database.SubscriptionStatusRepository.kt</ID>
    <ID>NewLineAtEndOfFile:WgHopMap.kt$com.celzero.bravedns.database.WgHopMap.kt</ID>
    <ID>SerialVersionUIDInSerializableClass:ConnTrackerMetaData.kt$ConnTrackerMetaData : Serializable</ID>
    <ID>SerialVersionUIDInSerializableClass:ConnectionSummary.kt$ConnectionSummary : Serializable</ID>
    <ID>SerialVersionUIDInSerializableClass:CustomIp.kt$CustomIp : Serializable</ID>
    <ID>SerialVersionUIDInSerializableClass:FileTag.kt$FileTag : Serializable</ID>
    <ID>SwallowedException:AboutViewModel.kt$AboutViewModel$e: Exception</ID>
    <ID>SwallowedException:BackupHelper.kt$BackupHelper.Companion$e: Exception</ID>
    <ID>SwallowedException:ConnectionMonitor.kt$ConnectionMonitor$e: Exception</ID>
    <ID>SwallowedException:Converters.kt$Converters$e: IllegalArgumentException</ID>
    <ID>SwallowedException:DomainRulesManager.kt$DomainRulesManager$e: Exception</ID>
    <ID>SwallowedException:FavIconDownloader.kt$FavIconDownloader$e: Exception</ID>
    <ID>SwallowedException:GoVpnAdapter.kt$GoVpnAdapter$e: Exception</ID>
    <ID>SwallowedException:HomeScreenActivity.kt$HomeScreenActivity$e: ActivityNotFoundException</ID>
    <ID>SwallowedException:HomeScreenActivity.kt$HomeScreenActivity$e: Exception</ID>
    <ID>SwallowedException:HomeScreenActivity.kt$HomeScreenActivity$e: IllegalArgumentException</ID>
    <ID>SwallowedException:IPTracker.kt$IPTracker$e: Exception</ID>
    <ID>SwallowedException:InetAddresses.kt$InetAddresses$e: Exception</ID>
    <ID>SwallowedException:InetEndpoint.kt$InetEndpoint$e: UnknownHostException</ID>
    <ID>SwallowedException:LogDatabase.kt$LogDatabase.Companion$e: SQLiteException</ID>
    <ID>SwallowedException:LogExportWorker.kt$LogExportWorker$e: Exception</ID>
    <ID>SwallowedException:Logger.kt$Logger$e: Exception</ID>
    <ID>SwallowedException:NetworkBindingService.kt$NetworkBindingService$e: Exception</ID>
    <ID>SwallowedException:NonStoreAppUpdater.kt$NonStoreAppUpdater.&lt;no name provided&gt;$e: Exception</ID>
    <ID>SwallowedException:Peer.kt$Peer.Builder$e: Exception</ID>
    <ID>SwallowedException:RestoreAgent.kt$RestoreAgent$e: IOException</ID>
    <ID>SwallowedException:SsidPermissionManager.kt$SsidPermissionManager$e: Exception</ID>
    <ID>SwallowedException:TcpProxyHelper.kt$TcpProxyHelper$e: Exception</ID>
    <ID>SwallowedException:Utilities.kt$Utilities$e: IllegalArgumentException</ID>
    <ID>SwallowedException:Utilities.kt$Utilities$e: IllegalStateException</ID>
    <ID>SwallowedException:Utilities.kt$Utilities$e: PackageManager.NameNotFoundException</ID>
    <ID>ThrowingExceptionsWithoutMessageOrCause:AppConfig.kt$AppConfig$Exception()</ID>
    <ID>ThrowingExceptionsWithoutMessageOrCause:NetLogTracker.kt$NetLogTracker$Exception()</ID>
    <ID>ThrowsCount:Config.kt$Config.Companion$@Throws(IOException::class, BadConfigException::class) fun parse(reader: BufferedReader): Config</ID>
    <ID>ThrowsCount:InetAddresses.kt$InetAddresses$@Throws(ParseException::class) fun parse(address: String): InetAddress</ID>
    <ID>ThrowsCount:InetEndpoint.kt$InetEndpoint.Companion$@Throws(ParseException::class) fun parse(endpoint: String): InetEndpoint</ID>
    <ID>TooGenericExceptionCaught:AboutViewModel.kt$AboutViewModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AllowedAppsBubbleViewModel.kt$AllowedAppsBubbleViewModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AppDatabase.kt$AppDatabase.Companion.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AppDownloadManager.kt$AppDownloadManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BackupAgent.kt$BackupAgent$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BackupHelper.kt$BackupHelper.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BackupRestoreDialog.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BlockedAppsBubbleViewModel.kt$BlockedAppsBubbleViewModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BlocklistDownloadHelper.kt$BlocklistDownloadHelper.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BlocklistDownloadHelper.kt$BlocklistDownloadHelper.Companion$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:BraveTileService.kt$BraveTileService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BraveVPNService.kt$BraveVPNService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BraveVPNService.kt$BraveVPNService$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:BraveVPNService.kt$BraveVPNService$iex: Exception</ID>
    <ID>TooGenericExceptionCaught:BraveVPNService.kt$BraveVPNService.LanIp$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BubbleActivity.kt$BubbleActivity$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BubbleHelper.kt$BubbleHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BugReportCollector.kt$BugReportCollector$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BugReportZipper.kt$BugReportZipper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CheckoutViewModel.kt$CheckoutViewModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConnectionMonitor.kt$ConnectionMonitor$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConnectionTracer.kt$ConnectionTracer$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ConnectivityCheckHelper.kt$ConnectivityCheckHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConsoleLogViewModel.kt$ConsoleLogViewModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CustomLanIpDialog.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Daemons.kt$CoFactory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DataUsageUpdater.kt$DataUsageUpdater$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DiagnosticsManager.kt$DiagnosticsManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DnsConfigurationManager.kt$DnsConfigurationManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DomainRulesManager.kt$DomainRulesManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DownloadWatcher.kt$DownloadWatcher$e: Exception</ID>
    <ID>TooGenericExceptionCaught:EncryptedFileManager.kt$EncryptedFileManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:EnhancedBugReport.kt$EnhancedBugReport$e: Exception</ID>
    <ID>TooGenericExceptionCaught:EventLogger.kt$EventLogger$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FavIconDownloader.kt$FavIconDownloader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FileHandleWorker.kt$FileHandleWorker$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FirewallManager.kt$FirewallManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FirewallRuleEvaluator.kt$FirewallRuleEvaluator$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:GlobalExceptionHandler.kt$GlobalExceptionHandler$e: Exception</ID>
    <ID>TooGenericExceptionCaught:GoVpnAdapter.kt$GoVpnAdapter$e: Exception</ID>
    <ID>TooGenericExceptionCaught:GoVpnAdapter.kt$GoVpnAdapter$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:HomeScreenActivity.kt$HomeScreenActivity$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HomeScreenActivity.kt$HomeScreenActivity$e: NullPointerException</ID>
    <ID>TooGenericExceptionCaught:IPTracker.kt$IPTracker$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InetAddresses.kt$InetAddresses$e: Exception</ID>
    <ID>TooGenericExceptionCaught:IpInfoDownloader.kt$IpInfoDownloader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:IpRulesManager.kt$IpRulesManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:IpRulesManager.kt$IpRulesManager$e: NullPointerException</ID>
    <ID>TooGenericExceptionCaught:LauncherSwitcher.kt$LauncherSwitcher$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LocalBlocklistCoordinator.kt$LocalBlocklistCoordinator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LocalBlocklistCoordinator.kt$LocalBlocklistCoordinator$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:LogDatabase.kt$LogDatabase.Companion$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:LogDatabase.kt$LogDatabase.Companion.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LogExportWorker.kt$LogExportWorker$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Logger.kt$Logger$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkBindingService.kt$NetworkBindingService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkReachabilityDialog.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NonStoreAppUpdater.kt$NonStoreAppUpdater.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PaymentWorker.kt$PaymentWorker$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Peer.kt$Peer.Builder$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PingTestScreen.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PipKeyManager.kt$PipKeyManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:QrCodeFromFileScanner.kt$QrCodeFromFileScanner$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RefreshDatabase.kt$RefreshDatabase$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:RemoteBlocklistCoordinator.kt$RemoteBlocklistCoordinator$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:RestoreAgent.kt$RestoreAgent$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RestoreAgent.kt$RestoreAgent$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:RethinkBlocklistManager.kt$RethinkBlocklistManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RetrofitManager.kt$RetrofitManager.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SsidPermissionManager.kt$SsidPermissionManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StateMachineFramework.kt$StateMachine$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SubscriptionStatusRepository.kt$SubscriptionStatusRepository$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TcpProxyHelper.kt$TcpProxyHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TempAllowExpiryWorker.kt$TempAllowExpiryWorker$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TunnelImporter.kt$TunnelImporter$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:UIUtils.kt$UIUtils$e: Exception</ID>
    <ID>TooGenericExceptionCaught:UnderlyingNetworkManager.kt$UnderlyingNetworkManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Utilities.kt$Utilities$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VpnController.kt$VpnController$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VpnNotificationManager.kt$VpnNotificationManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WgAddPeerDialog.kt$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:WgConfigEditorScreen.kt$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:WgHopManager.kt$WgHopManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WgInterface.kt$WgInterface.Builder$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WgInterface.kt$WgInterface.Builder$e: NullPointerException</ID>
    <ID>TooGenericExceptionCaught:WireguardManager.kt$WireguardManager$e: Exception</ID>
    <ID>TooManyFunctions:AppConfig.kt$AppConfig</ID>
    <ID>TooManyFunctions:AppConnectionsViewModel.kt$AppConnectionsViewModel : ViewModel</ID>
    <ID>TooManyFunctions:AppDatabase.kt$AppDatabase : RoomDatabase</ID>
    <ID>TooManyFunctions:AppDownloadManager.kt$AppDownloadManager</ID>
    <ID>TooManyFunctions:AppInfoDAO.kt$AppInfoDAO</ID>
    <ID>TooManyFunctions:AppInfoRepository.kt$AppInfoRepository</ID>
    <ID>TooManyFunctions:AppInfoViewModel.kt$AppInfoViewModel : ViewModel</ID>
    <ID>TooManyFunctions:BackupAgent.kt$BackupAgent : WorkerKoinComponent</ID>
    <ID>TooManyFunctions:BackupRestoreDialog.kt$com.celzero.bravedns.ui.bottomsheet.BackupRestoreDialog.kt</ID>
    <ID>TooManyFunctions:BlocklistDownloadHelper.kt$BlocklistDownloadHelper$Companion</ID>
    <ID>TooManyFunctions:BraveVPNService.kt$BraveVPNService : VpnServiceNetworkListenerBridgeOnSharedPreferenceChangeListener</ID>
    <ID>TooManyFunctions:BubbleHelper.kt$BubbleHelper</ID>
    <ID>TooManyFunctions:BubbleScreen.kt$com.celzero.bravedns.ui.compose.bubble.BubbleScreen.kt</ID>
    <ID>TooManyFunctions:BugReportZipper.kt$BugReportZipper</ID>
    <ID>TooManyFunctions:ConfigureOtherDnsScreen.kt$com.celzero.bravedns.ui.compose.dns.ConfigureOtherDnsScreen.kt</ID>
    <ID>TooManyFunctions:ConnTrackerDialog.kt$com.celzero.bravedns.ui.bottomsheet.ConnTrackerDialog.kt</ID>
    <ID>TooManyFunctions:ConnectionMonitor.kt$ConnectionMonitor : KoinComponentDiagnosticsListener</ID>
    <ID>TooManyFunctions:ConnectionMonitor.kt$ConnectionMonitor$NetworkRequestHandler</ID>
    <ID>TooManyFunctions:ConnectionTrackerDAO.kt$ConnectionTrackerDAO</ID>
    <ID>TooManyFunctions:ConnectionTrackerRepository.kt$ConnectionTrackerRepository : KoinComponent</ID>
    <ID>TooManyFunctions:ConnectivityCheckHelper.kt$ConnectivityCheckHelper</ID>
    <ID>TooManyFunctions:CustomDomainDAO.kt$CustomDomainDAO</ID>
    <ID>TooManyFunctions:CustomDomainRepository.kt$CustomDomainRepository</ID>
    <ID>TooManyFunctions:CustomIpDao.kt$CustomIpDao</ID>
    <ID>TooManyFunctions:CustomIpRepository.kt$CustomIpRepository</ID>
    <ID>TooManyFunctions:DesignComponents.kt$com.celzero.bravedns.ui.compose.theme.DesignComponents.kt</ID>
    <ID>TooManyFunctions:DnsCryptEndpointDAO.kt$DnsCryptEndpointDAO</ID>
    <ID>TooManyFunctions:DnsCryptRelayEndpointDAO.kt$DnsCryptRelayEndpointDAO</ID>
    <ID>TooManyFunctions:DnsLogAdapter.kt$com.celzero.bravedns.adapter.DnsLogAdapter.kt</ID>
    <ID>TooManyFunctions:DnsLogDAO.kt$DnsLogDAO</ID>
    <ID>TooManyFunctions:DnsProxyEndpointDAO.kt$DnsProxyEndpointDAO</ID>
    <ID>TooManyFunctions:DnsSettingsViewModel.kt$DnsSettingsViewModel : ViewModel</ID>
    <ID>TooManyFunctions:DoHEndpointDAO.kt$DoHEndpointDAO</ID>
    <ID>TooManyFunctions:DoTEndpointDAO.kt$DoTEndpointDAO</ID>
    <ID>TooManyFunctions:DomainRulesManager.kt$DomainRulesManager : KoinComponent</ID>
    <ID>TooManyFunctions:EventDao.kt$EventDao</ID>
    <ID>TooManyFunctions:EventLogger.kt$EventLogger</ID>
    <ID>TooManyFunctions:FirewallAppListAdapter.kt$com.celzero.bravedns.adapter.FirewallAppListAdapter.kt</ID>
    <ID>TooManyFunctions:FirewallManager.kt$FirewallManager : KoinComponent</ID>
    <ID>TooManyFunctions:FirewallRuleEvaluator.kt$FirewallRuleEvaluator</ID>
    <ID>TooManyFunctions:GoVpnAdapter.kt$GoVpnAdapter : KoinComponent</ID>
    <ID>TooManyFunctions:HomeScreenActivity.kt$HomeScreenActivity : AppCompatActivity</ID>
    <ID>TooManyFunctions:HomeScreenViewModel.kt$HomeScreenViewModel : ViewModel</ID>
    <ID>TooManyFunctions:IPUtil.kt$IPUtil$Companion</ID>
    <ID>TooManyFunctions:IpRulesManager.kt$IpRulesManager : KoinComponent</ID>
    <ID>TooManyFunctions:LocalBlocklistCoordinator.kt$LocalBlocklistCoordinator : CoroutineWorkerKoinComponent</ID>
    <ID>TooManyFunctions:LogDatabase.kt$LogDatabase : RoomDatabase</ID>
    <ID>TooManyFunctions:Logger.kt$Logger : KoinComponent</ID>
    <ID>TooManyFunctions:NetworkBindingService.kt$NetworkBindingService</ID>
    <ID>TooManyFunctions:ODoHEndpointDAO.kt$ODoHEndpointDAO</ID>
    <ID>TooManyFunctions:OneWgConfigAdapter.kt$com.celzero.bravedns.adapter.OneWgConfigAdapter.kt</ID>
    <ID>TooManyFunctions:OrbotHelper.kt$OrbotHelper</ID>
    <ID>TooManyFunctions:Peer.kt$Peer</ID>
    <ID>TooManyFunctions:Peer.kt$Peer$Builder</ID>
    <ID>TooManyFunctions:PersistentState.kt$PersistentState : SimpleKrateKoinComponent</ID>
    <ID>TooManyFunctions:PipKeyManager.kt$PipKeyManager : KoinComponent</ID>
    <ID>TooManyFunctions:ProxyAppMappingRepository.kt$ProxyAppMappingRepository</ID>
    <ID>TooManyFunctions:ProxyApplicationMappingDAO.kt$ProxyApplicationMappingDAO</ID>
    <ID>TooManyFunctions:ProxyEndpointDAO.kt$ProxyEndpointDAO</ID>
    <ID>TooManyFunctions:ProxyEndpointRepository.kt$ProxyEndpointRepository</ID>
    <ID>TooManyFunctions:ProxyManager.kt$ProxyManager : KoinComponent</ID>
    <ID>TooManyFunctions:RefreshDatabase.kt$RefreshDatabase</ID>
    <ID>TooManyFunctions:RestoreAgent.kt$RestoreAgent : CoroutineWorkerKoinComponent</ID>
    <ID>TooManyFunctions:RethinkBlocklistManager.kt$RethinkBlocklistManager : KoinComponent</ID>
    <ID>TooManyFunctions:RethinkDnsEndpointDao.kt$RethinkDnsEndpointDao</ID>
    <ID>TooManyFunctions:RethinkDnsEndpointRepository.kt$RethinkDnsEndpointRepository</ID>
    <ID>TooManyFunctions:RethinkLocalFileTagDao.kt$RethinkLocalFileTagDao</ID>
    <ID>TooManyFunctions:RethinkLocalFileTagRepository.kt$RethinkLocalFileTagRepository</ID>
    <ID>TooManyFunctions:RethinkLogAdapter.kt$com.celzero.bravedns.adapter.RethinkLogAdapter.kt</ID>
    <ID>TooManyFunctions:RethinkLogDao.kt$RethinkLogDao</ID>
    <ID>TooManyFunctions:RethinkRemoteFileTagDao.kt$RethinkRemoteFileTagDao</ID>
    <ID>TooManyFunctions:SsidPermissionManager.kt$SsidPermissionManager</ID>
    <ID>TooManyFunctions:StateMachineFramework.kt$StateMachine&lt;S : State, E : Event, D : Any&gt;</ID>
    <ID>TooManyFunctions:StatsSummaryDao.kt$StatsSummaryDao</ID>
    <ID>TooManyFunctions:SubscriptionStatusDao.kt$SubscriptionStatusDao</ID>
    <ID>TooManyFunctions:SubscriptionStatusRepository.kt$SubscriptionStatusRepository</ID>
    <ID>TooManyFunctions:TcpProxyHelper.kt$TcpProxyHelper : KoinComponent</ID>
    <ID>TooManyFunctions:UIUtils.kt$UIUtils</ID>
    <ID>TooManyFunctions:VpnController.kt$VpnController : KoinComponent</ID>
    <ID>TooManyFunctions:WgConfigAdapter.kt$com.celzero.bravedns.adapter.WgConfigAdapter.kt</ID>
    <ID>TooManyFunctions:WgConfigFilesDAO.kt$WgConfigFilesDAO</ID>
    <ID>TooManyFunctions:WgConfigFilesRepository.kt$WgConfigFilesRepository</ID>
    <ID>TooManyFunctions:WgHopManager.kt$WgHopManager : KoinComponent</ID>
    <ID>TooManyFunctions:WgInterface.kt$WgInterface</ID>
    <ID>TooManyFunctions:WgInterface.kt$WgInterface$Builder</ID>
    <ID>TooManyFunctions:WireguardManager.kt$WireguardManager : KoinComponent</ID>
    <ID>UnusedParameter:AboutScreen.kt$onTokenDoubleTap: () -&gt; Unit</ID>
    <ID>UnusedParameter:AppDatabase.kt$AppDatabase.Companion$context: Context</ID>
    <ID>UnusedParameter:AppInfoScreen.kt$prevConnStat: FirewallManager.ConnectionStatus</ID>
    <ID>UnusedParameter:AppListScreen.kt$onBackClick: (() -&gt; Unit)? = null</ID>
    <ID>UnusedParameter:BackupRestoreDialog.kt$activity: FragmentActivity</ID>
    <ID>UnusedParameter:ConfigureRethinkBasicScreen.kt$appDownloadManager: AppDownloadManager</ID>
    <ID>UnusedParameter:ConfigureRethinkBasicScreen.kt$context: Context</ID>
    <ID>UnusedParameter:ConfigureRethinkBasicScreen.kt$plusFilterTags: List&lt;FileTag&gt;</ID>
    <ID>UnusedParameter:ConfigureRethinkBasicScreen.kt$showPlusFilterSheet: Boolean</ID>
    <ID>UnusedParameter:ConnTrackerDialog.kt$persistentState: PersistentState</ID>
    <ID>UnusedParameter:ConnectionTrackerAdapter.kt$context: Context</ID>
    <ID>UnusedParameter:DnsDetailScreen.kt$context: Context</ID>
    <ID>UnusedParameter:DnsDetailScreen.kt$onBackClick: (() -&gt; Unit)? = null</ID>
    <ID>UnusedParameter:DnsDetailScreen.kt$persistentState: PersistentState</ID>
    <ID>UnusedParameter:DnsLogAdapter.kt$context: Context</ID>
    <ID>UnusedParameter:FirewallRuleEvaluator.kt$FirewallRuleEvaluator$rinr: Boolean</ID>
    <ID>UnusedParameter:FirewallRuleEvaluator.kt$FirewallRuleEvaluator$uid: Int</ID>
    <ID>UnusedParameter:GoVpnAdapter.kt$GoVpnAdapter$option: Long</ID>
    <ID>UnusedParameter:HomeScreen.kt$onSponsorClick: () -&gt; Unit</ID>
    <ID>UnusedParameter:HomeScreenActivity.kt$HomeScreenActivity$screenToLoad: Int</ID>
    <ID>UnusedParameter:LocalAdvancedViewAdapter.kt$context: Context</ID>
    <ID>UnusedParameter:NetworkLogsScreen.kt$eventLogger: EventLogger</ID>
    <ID>UnusedParameter:NetworkLogsScreen.kt$rethinkLogRepository: RethinkLogRepository</ID>
    <ID>UnusedParameter:NetworkLogsScreen.kt$rethinkLogViewModel: RethinkLogViewModel</ID>
    <ID>UnusedParameter:ProxySettingsScreen.kt$eventLogger: EventLogger</ID>
    <ID>UnusedParameter:ProxySettingsScreen.kt$persistentState: PersistentState</ID>
    <ID>UnusedParameter:RemoteAdvancedViewAdapter.kt$context: Context</ID>
    <ID>UnusedParameter:RethinkLocalFileTagRepository.kt$RethinkLocalFileTagRepository$id: Int</ID>
    <ID>UnusedParameter:RethinkLogAdapter.kt$context: Context</ID>
    <ID>UnusedParameter:SsidPermissionManager.kt$SsidPermissionManager$permissions: Array&lt;out String&gt;</ID>
    <ID>UnusedParameter:TunnelSettingsScreen.kt$context: Context</ID>
    <ID>UnusedParameter:VpnConnectionHandler.kt$VpnConnectionHandler$rethinkUid: Int</ID>
    <ID>UnusedParameter:WgHopAdapter.kt$isActive: Boolean</ID>
    <ID>UnusedParameter:WgHopAdapter.kt$selectedId: Int</ID>
    <ID>UnusedParameter:WgInterface.kt$WgInterface.Builder$apps: CharSequence?</ID>
    <ID>UnusedParameter:WgPeersAdapter.kt$context: Context</ID>
    <ID>UnusedPrivateMember:AppWiseIpsAdapter.kt$private fun calculatePercentage(c: Double, maxValue: Int): Pair&lt;Int, Int&gt;</ID>
    <ID>UnusedPrivateMember:ConnectivityCheckHelper.kt$ConnectivityCheckHelper$@Deprecated("Use checkTcpConnection instead", ReplaceWith("checkTcpConnection(nw, host, 53, \"53\")")) private suspend fun tcp53(nw: Network?, host: String): Boolean</ID>
    <ID>UnusedPrivateMember:ConnectivityCheckHelper.kt$ConnectivityCheckHelper$@Deprecated("Use checkTcpConnection instead", ReplaceWith("checkTcpConnection(nw, host, 80, \"80\")")) private suspend fun tcp80(nw: Network?, host: String): Boolean</ID>
    <ID>UnusedPrivateMember:ConnectivityCheckHelper.kt$ConnectivityCheckHelper$@Deprecated("Use closeQuietly instead", ReplaceWith("closeQuietly(closeable)")) private fun clos(closeable: Closeable?)</ID>
    <ID>UnusedPrivateMember:HomeNavigation.kt$private fun detailedStatsRoute(typeId: Int, timeCategory: Int): String</ID>
    <ID>UnusedPrivateMember:HomeNavigation.kt$private fun domainConnectionsRoute( type: DomainConnectionsInputType, flag: String, domain: String, asn: String, ip: String, isBlocked: Boolean, timeCategory: DomainConnectionsViewModel.TimeCategory ): String</ID>
    <ID>UnusedPrivateMember:HomeScreenActivity.kt$HomeScreenActivity$private fun handleShowAppExitInfo()</ID>
    <ID>UnusedPrivateMember:HomeScreenActivity.kt$HomeScreenActivity$private fun hasAnyLogsAvailable(): Boolean</ID>
    <ID>UnusedPrivateMember:HomeScreenActivity.kt$HomeScreenActivity$private fun openCustomIpScreen()</ID>
    <ID>UnusedPrivateMember:HomeScreenActivity.kt$HomeScreenActivity$private fun openUniversalFirewallScreen()</ID>
    <ID>UnusedPrivateMember:HomeScreenActivity.kt$HomeScreenActivity$private fun showDatabaseDumpDialog(title: String, dump: String)</ID>
    <ID>UnusedPrivateMember:HomeScreenActivity.kt$HomeScreenActivity$private fun startAppsActivity()</ID>
    <ID>UnusedPrivateMember:HomeScreenActivity.kt$HomeScreenActivity$private fun startDnsActivity(screenToLoad: Int)</ID>
    <ID>UnusedPrivateMember:HomeScreenActivity.kt$HomeScreenActivity$private fun startFirewallActivity(screenToLoad: Int)</ID>
    <ID>UnusedPrivateProperty:AboutViewModel.kt$AboutViewModel$private var lastAppExitInfoDialogInvokeTime = INIT_TIME_MS</ID>
    <ID>UnusedPrivateProperty:AlertsViewModel.kt$AlertsViewModel$private val connectionTrackerDao: ConnectionTrackerDAO</ID>
    <ID>UnusedPrivateProperty:AlertsViewModel.kt$AlertsViewModel$private val dnsLogDao: DnsLogDAO</ID>
    <ID>UnusedPrivateProperty:AppInfoScreen.kt$val lifecycleOwner = LocalLifecycleOwner.current</ID>
    <ID>UnusedPrivateProperty:AppWiseDomainLogsScreen.kt$val context = LocalContext.current</ID>
    <ID>UnusedPrivateProperty:AppWiseIpLogsScreen.kt$val lifecycleOwner = LocalLifecycleOwner.current</ID>
    <ID>UnusedPrivateProperty:AppWiseIpsAdapter.kt$val context = LocalContext.current</ID>
    <ID>UnusedPrivateProperty:BadConfigException.kt$BadConfigException.Location$name: String</ID>
    <ID>UnusedPrivateProperty:BadConfigException.kt$BadConfigException.Section$name: String</ID>
    <ID>UnusedPrivateProperty:BraveVPNService.kt$BraveVPNService$private var lastSubscriptionCheckTime: Long = 0</ID>
    <ID>UnusedPrivateProperty:BraveVPNService.kt$BraveVPNService.Companion$// subscription check interval in milliseconds 1 hour // TODO: increase it to 6 hours? private const val PLUS_CHECK_INTERVAL = 1 * 60 * 60 * 1000L</ID>
    <ID>UnusedPrivateProperty:BraveVPNService.kt$BraveVPNService.Companion$// win last connected threshold in milliseconds private const val WIN_LAST_CONNECTED_THRESHOLD_MS = 60 * 60 * 1000L // 60 minutes</ID>
    <ID>UnusedPrivateProperty:CheckoutViewModel.kt$CheckoutViewModel$private val persistentState: PersistentState</ID>
    <ID>UnusedPrivateProperty:CheckoutViewModel.kt$CheckoutViewModel$val accountId = id.substring(0, 64)</ID>
    <ID>UnusedPrivateProperty:ConnTrackerDialog.kt$val context = LocalContext.current</ID>
    <ID>UnusedPrivateProperty:ConnectionTrackerRepository.kt$ConnectionTrackerRepository$private val persistentState by inject&lt;PersistentState&gt;()</ID>
    <ID>UnusedPrivateProperty:ConsoleLogAdapter.kt$val context = LocalContext.current</ID>
    <ID>UnusedPrivateProperty:CustomRulesScreen.kt$val context = LocalContext.current</ID>
    <ID>UnusedPrivateProperty:DesignComponents.kt$// Extension for clickable modifier private val spacerDp = 1.dp // For internal use</ID>
    <ID>UnusedPrivateProperty:DnsConfigurationManager.kt$DnsConfigurationManager$private val context: Context</ID>
    <ID>UnusedPrivateProperty:DnsListScreen.kt$val context = LocalContext.current</ID>
    <ID>UnusedPrivateProperty:DnsLogTracker.kt$DnsLogTracker.Companion$private const val START_RESPONSE = "START"</ID>
    <ID>UnusedPrivateProperty:FavIconDownloader.kt$FavIconDownloader.Companion$private const val DEFAULT_DELAY = 15000L // 15 seconds</ID>
    <ID>UnusedPrivateProperty:GoVpnAdapter.kt$GoVpnAdapter$val prev = Settings.dupTunFd(FIRESTACK_MUST_DUP_TUNFD)</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_ADVANCED_SETTINGS = "advancedSettings"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_ALERTS = "alerts"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_ANTI_CENSORSHIP = "antiCensorship"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_APP_INFO = "appInfo"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_APP_LIST = "appList"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_APP_LOCK = "appLock"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_APP_WISE_IP_LOGS = "appWiseIpLogs"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_CONFIGURE_RETHINK_BASIC = "configureRethinkBasic"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_CONSOLE_LOGS = "consoleLogs"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_CUSTOM_RULES = "customRules"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_DNS_DETAIL = "dnsDetail"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_DNS_LIST = "dnsList"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_EVENTS = "events"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_FIREWALL_SETTINGS = "firewallSettings"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_MISC_SETTINGS = "miscSettings"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_NETWORK_LOGS = "networkLogs"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_PING_TEST = "pingTest"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_PROXY_SETTINGS = "proxySettings"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_RPN_AVAILABILITY = "rpnAvailability"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_RPN_COUNTRIES = "rpnCountries"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_RPN_WIN_PROXY_DETAILS = "rpnWinProxyDetails"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_TCP_PROXY_MAIN = "tcpProxyMain"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_TUNNEL_SETTINGS = "tunnelSettings"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_WELCOME = "welcome"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$private const val ROUTE_WG_CONFIG_EDITOR = "wgConfigEditor"</ID>
    <ID>UnusedPrivateProperty:HomeNavigation.kt$val context = LocalContext.current</ID>
    <ID>UnusedPrivateProperty:NetworkBindingService.kt$NetworkBindingService$private val scope: CoroutineScope</ID>
    <ID>UnusedPrivateProperty:NetworkBindingService.kt$NetworkBindingService$val rethinkUid = try { vpnService.packageManager.getApplicationInfo(vpnService.packageName, 0).uid } catch (e: Exception) { return false }</ID>
    <ID>UnusedPrivateProperty:PersistentState.kt$PersistentState$// universal rule, block all non A &amp; AAAA dns responses private var _blockOtherDnsRecordTypes by booleanPref("block_non_ip_dns_responses").withDefault&lt;Boolean&gt;(false)</ID>
    <ID>UnusedPrivateProperty:PingTestScreen.kt$val context = LocalContext.current</ID>
    <ID>UnusedPrivateProperty:PipKeyManager.kt$PipKeyManager$private const val ERR_UNSUPPORTED_DEVICE = "Rethink+ is not supported on this device"</ID>
    <ID>UnusedPrivateProperty:PipKeyManager.kt$PipKeyManager$private const val ERR_UPDATE_REQUIRED = "Rethink+ requires an update to the app"</ID>
    <ID>UnusedPrivateProperty:ProxyStateManager.kt$ProxyStateManager$private val scope: CoroutineScope</ID>
    <ID>UnusedPrivateProperty:ProxyStateManager.kt$ProxyStateManager.Companion$private const val TAG = "ProxyState"</ID>
    <ID>UnusedPrivateProperty:UnderlyingNetworkManager.kt$UnderlyingNetworkManager$private val scope: CoroutineScope</ID>
    <ID>UnusedPrivateProperty:VpnConnectionHandler.kt$VpnConnectionHandler.Companion$private const val IPV4_DNS_ADDR = 44</ID>
    <ID>UnusedPrivateProperty:VpnConnectionHandler.kt$VpnConnectionHandler.Companion$private const val IPV6_DNS_ADDR = 44</ID>
    <ID>UtilityClassWithPublicConstructor:BackupHelper.kt$BackupHelper</ID>
    <ID>UtilityClassWithPublicConstructor:Constants.kt$Constants</ID>
    <ID>UtilityClassWithPublicConstructor:DownloadConstants.kt$DownloadConstants</ID>
    <ID>UtilityClassWithPublicConstructor:KnownPorts.kt$KnownPorts</ID>
    <ID>UtilityClassWithPublicConstructor:RetrofitManager.kt$RetrofitManager</ID>
    <ID>VariableNaming:ConnectionTrackerRepository.kt$ConnectionTrackerRepository$private val BLOCKED_WINDOW_MS = 5 * 60 * 1000L // 5 minutes</ID>
  </CurrentIssues>
</SmellBaseline>
